{"pageProps":{"allPosts":[{"title":"Экспорт данных из SAP Query-отчета во внутреннюю таблицу через SPOOL","date":"2021-03-20T08:40:14.217Z","slug":"export-data-to-sap-spool","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120&v=4","url":"https://github.com/JustAddAcid"},"content":"\nГоспода, м'сье абапье и прочие любители подглядывать за страданиями! Представляю вашему вниманию очередной результат танцев с бубенцами. Который в этот раз будет чуть менее бесполезным. И (быть может) сэкономит время какому-нибудь заблудившемуся **SAP**-кодерасту.\n\nИногда хочется выть от боли, когда в очередной раз появляются требования выгрузки данных из стандартных или квази-стандартных отчетов SAP. Которые зачастую вообще не предусматривают какой-либо экспорт или расширение.\n\nДальше будет **ABAP** и рассказывания о подноготной **SAP ERP**. Если у вас нет вуайеристских наклонностей или профессионального интереса в дальнейшем тексте, то рекомендую закрыть страницу, чтобы не испытать экзистенциальный ужас от полученной информации.\n\nЧто ж, погружаемся, товарищи. Так сказать, пристегните ремни. Будет немного трясти ~~и пованивать~~.\n\n![Погружаемся!](../public/assets/blog/export-data-to-sap-spool/dipping.jpg)\n\n## Поехали.\nИтак, представим ситуацию: Вы сидите, неспешно ковыряете код. И тут прилетает задача —  достать данные из древнего отчета, нарисованного в **SAP Query** через **Report painter**; их немного обработать и отдать в другой интерфейс.\n\nКазалось бы, что может быть сложного? Ну, например, всё. \n\n### SAP Query (далее SQ)\nЭто сраный **SAP Query**. Пользователь мышой натыкивает нужные ему поля и форму отчета, а на выходе получает готовый отчет. Софтина сама собирает ABAP-программу по конфигу. Класна? Нет. \n\nКаждая дальнейшая правка отчета в пользовательской морде пересобирает целиком *всё*. Более того, никто не гарантирует, что программа пересоберется с тем же техническим названием. Ну и при переезде правок по ландшафту дев-тест-прод -> будет генерироваться разное название.\n\n**Вывод:** Вписаться в код отчета и вытащить данные перед их отображением —  не получится. Юзверь перезатрёт всё прямзавтра. А скорее всего —  вчера.\n\n![userflow](../public/assets/blog/export-data-to-sap-spool/userflow.jpg)\n\n### Report Painter\nЯ нарвался на *\"не совсем классическое\"*  использование **SQ**! Данные выводятся не напрямую, а проходят через *\"прослойку отрисовщика\"* (Report Painter). И воспользоваться стандартным FM **RSAQ_REMOTE_QUERY_CALL**, увы, не выйдет. \n\nТ.к. для заданного отчета вообще нет таких параметров, как *\"имя запроса\"* и  *\"группа пользователей\"*. Просто н**е**чего подавать в аргументы функции.\n\n**Вывод:** Увы, воспользоваться предусмотренными FM невозможно. \n\n### Это, мать вашу, не ALV\nА жаль. При отображении, ALV-таблицы постят свои мета-(и не очень мета)данные в глобальный скоуп сессии пользователя. И оттуда элементарно вытащить что угодно. Например, вот так:\n\n```abap\ncl_salv_bs_runtime_info=>set( EXPORTING display  = abap_false  \n\t\t\t\t\t\t\t\t\t\tmetadata = abap_true  \n\t\t\t\t\t\t\t\t\t\tdata     = abap_true ).\n\t\t\t\t\t\t\t\t\t\t\n\" submit report and return\n\ncl_salv_bs_runtime_info=>get_data_ref( IMPORTING r_data = ro_data ).\n\n\" do with ro_data what you want\n```\n\n### Не работает ... exporting list to memory\nНеобъяснимо, но факт. Несмотря на то, что SQ-отчеты де-факто рендерят стандартный лист!\n\nПопытка экспортировать таким способом просто подвешивает основной поток выполнения и ничего не делает. Чому? Об этом знает только аллах. \n\n```abap\nsubmit prog and return exporting list to memory. \" not working\n```\n\n### Но выход всегда есть\n*(особенно, если вы живёте достаточно высоко)*\n\nДавайте подумаем, **что может быть общего** между матричными принтерами, и решением моей задачи? \n\n![printer](../public/assets/blog/export-data-to-sap-spool/printer.jpeg)\n\nДа, теми самыми принтерами с рулоном ленты. Которые буквально печатают \"стуча\" по бумаге, как старые печатающие машинки. И которые могут использовать только *ASCII* символы. \n\n**А то**, что **SAP** *(Эдакая древняя громадина)* из коробки поддерживает *ASCII*-фикацию и печать всех отчетов, которые отрисовываются \"стандартным\" способом. Так это же то, что мне нужно! Такой текст будет элементарно распарсить после получения.\n\nДостаточно дёрнуть печать отчета, и вовремя подхватить *ASCII*-фицированный документ кодом! Получается что-то вроде этого:\n\nСоздаём фоновое задание, где будет выполняться рендеринг и попытка печати.\n\n```abap\nCALL FUNCTION 'JOB_OPEN'\n  EXPORTING\n    jobname          = kv_job_name\n  IMPORTING\n    jobcount         = lv_jobcount.\n```\n\nСобираем параметры печати. Нам нужно попросить программу напечататься сразу же после выполнения, и не показывать никаких диалогов. \n\n```abap\nCALL FUNCTION 'GET_PRINT_PARAMETERS'\n  EXPORTING\n    list_name      = 'TEST'\n    list_text      = 'SUBMIT this fucking program TO SAP-SPOOL'\n    immediately    = abap_true\n    no_dialog      = abap_true\n  IMPORTING\n    out_parameters = ls_params\n    valid          = lv_valid.\n```\n\nВызываем программу в фоне со всеми собранными параметрами. Конструкция **to sap-spool ... without spool** нисколько сап не смущает. И вполне корректно отрабатывает. \n\n```abap\nSUBMIT program_technical_name USING SELECTION-SET 'VAR1' \n      TO SAP-SPOOL SPOOL PARAMETERS ls_params \n      WITHOUT SPOOL DYNPRO \n      VIA JOB kv_job_name NUMBER lv_jobcount \n      AND RETURN.\n```\n\nТак, программу мы вызвали, теперь придется костылём дожидаться завершения фоновой задачи. Никаких ивентов и коллбэков тут нет. \n\n```abap\n\" Костыль ожидания завершения асинхронной жобы\nWHILE ls_empty IS INITIAL.\n  WAIT UP TO 5 SECONDS.\n  SELECT SINGLE * FROM tbtco INTO ls_empty WHERE jobname = kv_job_name AND jobcount = lv_jobcount AND status = 'F'.\nENDWHILE.\n```\n\nНу, собственно, всё. Фоновая задача завершена. В системе уже хранятся отрендеренные данные, и нам остаётся лишь их подхватить. \n\n```abap\nSELECT SINGLE listident\n  FROM tbtcp\n  INTO lv_listident\n  WHERE jobname = kv_job_name\n    AND jobcount = lv_jobcount.\n \nCHECK lv_listident IS NOT INITIAL.\n \nlv_rqident = lv_listident.\n \nCALL FUNCTION 'RSPO_RETURN_ABAP_SPOOLJOB'\n  EXPORTING\n    rqident              = lv_rqident\n  TABLES\n    buffer               = lt_buffer.\n```\n\nВ результате получаем внутрённюю таблицу **lt_buffer** из строк отчета. Её элементарно разбирать на куски, и вытаскивать нужные нам значения.\n \nСтолбцы в такой таблице разделены символом вертикальной черты '|' и ничего не стоит распарсить поля по отдельности. \n \n[Полный код на github gists здесь](https://gist.github.com/JustAddAcid/450d4cd5f1069dbac61c3e842508b969)\n\n<iframe frameborder=\"0\" style=\"border:none;width:100%;height:180px;\" width=\"100%\" height=\"180\" src=\"https://music.yandex.ru/iframe/#track/57987781/8763763\">Слушайте <a href='https://music.yandex.ru/album/8763763/track/57987781'>What the Fuck</a> — <a href='https://music.yandex.ru/artist/7756103'>RHODAMINE</a> на Яндекс.Музыке</iframe>\n\n#abap #танцы_с_бубном\n","ogImage":{"url":"/assets/blog/export-data-to-sap-spool/background.jpg"},"coverImage":"/assets/blog/export-data-to-sap-spool/background.jpg","issueId":"18","excerpt":"Объясняю необычный подход экспорта данных из отчетов SAP Query, которые отрисовывают данные через Report Painter. Через... Спул печати!"},{"title":"Ищем, в каких таблицах используется домен в ABAP","date":"2020-07-12T14:15:07.322Z","slug":"domain_where_used_list","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120&v=4","url":"https://github.com/JustAddAcid"},"content":"\nКакое здесь может быть введение? Продолжаю писать образовательные посты с небольшими вкраплениями абсурда, мемов и ненависти ко всему окружающему. Сегодня пишем утилиту. Под *SAP*. Своё отношение к разработке на этой платформе высказывал в [предыдущей статье](./zcl-date-abap).\n\nКонкретно эта программа — очень хороший пример, как сама система вынуждает разработчиков усложнять код и делать костыли, чтобы обойти абсолютно **искусственно** расставленные ограничения. Усаживайтесь поудобнее, мы начинаем!\n\n[NSFW MEME about \"присаживайтесь\"](../public/assets/blog/domain_where_used_list/device.jpg)\n\n## Немного теории\n\n**Що таке домени в *SAP*?**\n\n**Домены в SAP** — это то, что ~~нормальные~~ люди называют *типами данных*. То, как данные представлены непосредственно в памяти программы или *СУБД*: строка из N символов, int32, int64, float, enum из определенного набора значений и т.д.\n\nЕсть ещё такое понятие в *SAP*-тусовке как **элемент данных** (*data element*). Это \"тип данных на максималках\", который содержит в себе **не только** описание того, как эти данные лежат в памяти, но и дополнительные плюшки в виде:\n\n1. Дефолтный заголовок этого поля для разных языков (который подтягивается в поле ввода или заголовок таблицы по умолчанию)\n2. Ссылка на \"средство поиска\" — программу, которая помогает пользователю заполнить input значением. (Например, предоставить выбор из списка контрагентов с заданными параметрами)\n3. ... прочие второстепенные штуки\n\nТ.е. сначала объявляется домен, от него наследуется элемент данных, который уже используется для объявления переменных/объявления столбцов в таблицах БД.\n\n![Схема наследования](../public/assets/blog/domain_where_used_list/data_element.jpg)\n\nОукей, на первых парах нам этой информации достаточно. Остальное будем понимать по ходу процесса:\n\n## Процесс \n\n**Формулируем**, что мы хотим получить в итоге. Программу, которая:\n\n1. Принимает на вход **имя домена** и параметр:\n   1. Считать ли количество строк в таблицах\n2. Выводит список таблиц со следующими полями:\n   1. Имя таблицы, которая использует введенный домен\n   2. Название поля таблицы\n   3. Имя элемента данных этого поля\n   4. Количество строк **или** результат проверки на пустоту (в зависимости от входного параметра) \n\nНа самом деле, 95% этой задачи решаются очень быстро. Достаточно найти место в базе данных, где хранятся соответствия таблицы -> типа данных -> домена и сделать селект. (Благо, в БД SAP хранится **ВСЁ**, включая программный код)\n\nМетодом скоростного гугления обнаруживаем две таблицы, которые нам в этом могут помочь:\n\n1. **dd03l** — соответствие: таблица - поле - тип данных - домен\n2. **dd02l** — соответствие: таблица - класс таблицы (нас не интересуют объявленные типы таблиц, которые **не** используются в БД)\n\nНу и простейший селект из них:\n\n```abap\nSELECT DISTINCT dd03l~domname dd03l~rollname dd03l~fieldname\n    dd03l~tabname\n  INTO CORRESPONDING FIELDS OF TABLE rt_tables\n  FROM dd03l JOIN dd02l\n    ON dd03l~tabname = dd02l~tabname AND\n      dd03l~as4local = dd02l~as4local\n  WHERE\n    dd03l~domname IN ir_domains AND\n    \" Активные\n    dd03l~as4local = 'A' AND\n    \" Таблицы, которые используются в СУБД\n    dd02l~tabclass IN ('TRANSP', 'CLUSTER', 'POOL').\n```\n\nПроверка количества записей делается самым очевидным способом: **select count(\\*)** в цикле по всем таблицам.\n\n```abap\nLOOP AT lt_tables ASSIGNING <ls_table>.\n  SELECT SINGLE COUNT(*)\n    FROM (<ls_table>-tabname)\n    INTO lv_records_count.\n\n  \" [ .... ]\nENDLOOP.\n```\n\nКазалось бы, что может пойти не так? Всего лишь осталось реализовать проверку таблицы на пустоту, не делая select count(\\*) по всей таблице. \n\nПоскольку за выполнение запросов напрямую в **БД**, минуя прослойку **ABAP** — абаперов бьют по рукам (особенно при миграции на другую *СУБД*). Разработчикам приходится довольствоваться куцым подмножеством **sql**, который предоставляет ABAP API. В нём напрочь отсутствует не только *database-specific-features*, но и вполне стандартные вещи типа вложенных запросов.\n\nТ.е. вот такой простой и понятный запрос у нас ни за что не выполнится:\n```sql\nselect count(*) \nfrom (select top 1 * \n      from TABLE)\n```\n\nПриходится изобретать велосипед. И единственным выходом в этой ситуации будет попытка сделать селект **хотя бы одной** записи из таблицы и проверка на успех.\n\nСказано-сделано:\n```abap\nLOOP AT lt_tables ASSIGNING <ls_table>.\n  SELECT SINGLE *\n    FROM (<ls_table>-tabname)\n    INTO \" ...\n  \" Так, стоп. А куда присваивать значение?\n  \" [ .... ]\nENDLOOP.\n```\n\nБлок **into %var%** пропустить нельзя. Без него компиллятор сваливается с ошибкой. (Про ABAP-подобие байткода как-нибудь в другой раз)\n\nА куда присваивать значения, если заранее неизвестен тип данных? В **ABAP** таких \"безразмерных\" типов нет. Так что придется как-то объявлять переменные в рантайме. Но с этим не всё так гладко! :)\n\n## Длинное отступление про принцип объявления переменных в ABAP\n\nКазалось бы, о чем здесь рассказывать? Почти каждый относительно-высокоуровневый язык предоставляет очень простой *API* для объявления переменных. \n\nВ данном случае, переменные объявляются ключевым словом **DATA**, далее идет указание имени переменной и её тип:\n```abap\ndata some_name type string.\n```\n\nНо, поскольку *abap* — достаточно старый язык, он тянет за собой весьма странное легаси-поведение, которое в современном мире кажется моветоном. Например:\n```abap\nif 1 = 1.\n    data some_string type string.\n    some_string = 'hello world'.\nendif.\n\nwrite some_string.\n```\nУважаемые знатоки, внимание вопрос: выполнится ли этот код без ошибки? И выведется ли *hello world?*<br>\nПравильные ответы: **да и да**.\n\nЕсли вы на секунду подумали, что объявление переменных в *abap* ведет себя так же, как ключевое слово **var** в *JavaScript*, и переменная *\"вываливается\"* за текущий блок, то спешу вас разочаровать... \n```abap\nif 1 = 2.\n    \" Никогда не выполнится\n    data some_string type string.\nendif.\n\nsome_string = 'hello world'.\nwrite some_string. \"hello world \n\"(да, это работает)\n```\n\nНесмотря на то, что выполнение основного интерпретатора программы **никогда** не зайдёт в блок **IF**, переменная всё равно объявится!\n\n**N.B.**: перед выполнением кода, его быстренько пробегает интерпретатор и выделяет память под **все** используемые переменные в этой подпрограмме/методе.\n\nА объявленные переменные будут доступны в **любом месте** внутри метода/подпрограммы.\n\nНа самом деле, это больше похоже на хостинг функций в *JavaScript*. [Который хорошо описан здесь.](https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5)\n\nЗначит ли это, ~~что всё предопределено~~ что мы не можем выделять память в рантайме, когда на момент компилляции неизвестен тип? \n\nИ да, и нет. Саму переменную всё-таки придется объявить в виде ссылки на \"какую-то\" область памяти. А под неё уточнить тип и выделить память мы можем тогда, когда нам это потребуется. Выглядит это следующим образом:\n```abap\n\" Создаём переменную как ссылку на \"какие-то\" данные\ndata my_var type ref to data.\n\" Выделяем память под нужный тип данных\ncreate data my_var type ('typename').\n```\n\nЭто, конечно, прекрасно. Но так просто обращаться к этой области памяти и записывать/читать данные у нас не получится! :) Для этого нам потребуется познакомиться с ещё одним abap-концептом.\n\nЭто **field-symbols** — ссылки на уже **объявленные** переменные или строки таблицы. В примерах выше, где я делал цикл по таблице, я уже использовал *field-symbol*, куда присваивал адрес \"текущей\" строки в итерации цикла.\n\n```abap\nloop at table assigning <field-symbol>.\n\" do some shit with <field-symbol>\nendloop.\n```\n\nАналогичное действие придется выполнить и сейчас, чтобы полноценно воспользоваться выделенной памятью, как переменной:\n\n```abap\ndata my_var type ref to data.\n\" field-symbol можно объявлять с типом any\nfield-symbols <link_to_data> type any.\n\ncreate data my_var type ('typename').\nassign my_var->* to <link_to_data>.\n\n\" do some shit with <link_to_data>\n```\n\n## Финишная прямая:\n\nПрикручиваем эти концепты к нашей задаче:\n\n```abap\nFIELD-SYMBOLS: <lv_temp>  TYPE ANY.\nDATA lo_data TYPE REF TO data.\n\nLOOP AT it_tables ASSIGNING <ls_table>.\n  \n  CREATE DATA lo_data TYPE (<ls_table>-rollname).\n  ASSIGN lo_data->* TO <lv_temp>.\n\n  SELECT SINGLE (<ls_table>-fieldname)\n    FROM (<ls_table>-tabname)\n    INTO <lv_temp>.\n\n  \"sy-subrc аналог return-code в bash\n  IF sy-subrc = 0.\n    \" Обработка успешного селекта\n  ELSE.\n    \" Обработка пустой таблицы\n  ENDIF.\nENDLOOP.\n```\n\n## Заключение\n\nВнезапно этот костыль компилируется и работает. За очисткой данных можно не следить, т.к. за нас её выполнит сборщик мусора. Нам остаётся красиво нарисовать результаты пользователю, но это уже совсем другая история.\n\nВот именно таким образом тривиальные задачи усложняются внутри abap во много раз из-за излишних синтаксических ограничений. \n\nНапример, если бы было возможно выполнить вложенный *sql* или исключить блок \"into\" в запросах, то не пришлось бы в цикле выделять много памяти под абсолютно ненужную переменную, которая никак не обрабатывается в дальнейшем. \n\n(Кстати, создавая потенциальную утечку памяти, т.к. никто не знает, насколько качественно отрабатывает сборщик мусора)\n\nНа этом всё. Всех благ. :)\n\n#abap","ogImage":{"url":"/assets/blog/domain_where_used_list/background.jpg"},"coverImage":"/assets/blog/domain_where_used_list/background.jpg","issueId":"13","excerpt":"Пишем удобную утилиту, которая позволит найти, в каких таблицах БД используется выбранный домен и вычислить количество в них строк"},{"title":"Класс для удобного манипулирования датами в ABAP","date":"2020-05-24T14:15:07.322Z","slug":"zcl-date-abap","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120&v=4","url":"https://github.com/JustAddAcid"},"content":"\nНастало время делиться своей болью и страданиями. Меня зовут Носов Роман, и, мне очень стыдно в этом признаться, но я ~~алкоголик~~ иногда пишу на *ABAP*, чтобы не умереть с голоду.\n\n**Для тех, кто в танке и никогда не слышал, что это такое:** *ABAP* — это внутренний язык, на котором программируют (допиливают напильником) разные продукты от *SAP* . От допиливаний страдают, как сама система, так и программисты с пользователями. И всё действо со стороны больше напоминает истязания грешников в каком-нибудь круге ада по Данте.\n\nА **SAP** в свою очередь — ~~очень дорогая немецкая одинэска~~ компания которая делает ERP системы для крупных бизнесов.\n\nКак сказал неизвестный мудрец в комментариях на хабре:\n![SAP — это месть Гитлера за Сталинград](../public/assets/blog/zcl_date_abap/stalingrad.png)\n\n## И тут мне захотелось немного уменьшить градус боли (по части работы с датами)\n\n### Для начала немного теории:\n\nВ *ABAP* для хранения даты встроен специальный тип данных — *DATS* (или сокращенно — *D*). Представляет он из себя строку из 8 символов, в которой хранится по порядку: год,месяц,день. \n\n**Например:** '20190102' — это второе января 2019 года.\n\nТак же, для этого типа данных перегружены действия + и -. Которые отнимают и прибавляют дни к дате, или считают разницу в днях между двумя датами.\n\n```abap\nDATA: lv_dats  TYPE dats,\n      lv_dats2 TYPE dats,\n      lv_int   TYPE i.\n\n\" -/+ между dats и int возвращает dats с отнятыми/прибавленными днями\nlv_dats = '20190102'.\nlv_dats = lv_dats - 5.\nWRITE lv_dats. \" 28.12.2018\n\n\" -/+ между dats и dats возвращает int — разница между датами в днях\nlv_dats2 = '20190101'.\nlv_int = lv_dats2 - lv_dats. \" 01.01.2019 -  28.12.2018\nWRITE lv_int. \" 4\n```\n\nНо что делать, если очень хочется сделать инкремент месяца (не + 30 дней, а именно получить то же число следующего месяца, независимо от длины месяца (28-31))?\n\nДля этого есть громоздкий функциональный модуль RP_CALC_DATE_IN_INTERVAL. Умеет складывать/отнимать годы/месяцы/дни и возвращает валидную дату. \n\n```abap\nDATA: lv_dats  TYPE dats.\n\nlv_dats = '20190215'. \" 15.02.2019\n\nCALL FUNCTION 'RP_CALC_DATE_IN_INTERVAL'\n  EXPORTING\n    date      = lv_dats\n    days      = 0\n    months    = 1\n    signum    = '+'\n    years     = 0\n  IMPORTING\n    calc_date = lv_dats.\n\nwrite lv_dats. \" Искомое 15 марта\n```\n\nНо вы точно хотите использовать в своих программах вот такие уродливые конструкции?\n\nОтдельным пунктиком следует упомянуть про развлечения программистов с красивым форматированием даты. Огромные полотна кода с выдёргиваниями подстрок из даты, и конкатенации в нормальном виде.\n[Пример](https://www.erpworkbench.com/abap/date/date_format.htm \"Formatting SAP date field using ABAP\")\n\nА если очень хочется вместо номера месяца видеть его название? Май, апрель....\n\nА если очень хочется видеть названия месяцев на том языке, на котором запущен SAP? :)\nОгромные просторы для танцев с бубном и изобретаний велосипедов!\n\n## Z* разработки в SAP — бесконечная фабрика велосипедов\n![worst programming language](../public/assets/blog/zcl_date_abap/meme.jpg)\n\nИтак, нам нужен класс, который мог инкапсулировать в себе стандартный dats, но предоставлять удобный *API* для работы с датами, максимально скрывая уродливость языка *ABAP*.\n\nОн должен уметь:\n\n1. Прибавлять дни/месяцы/годы к текущей дате\n2. Иметь адекватные геттеры/сеттеры для дней/месяцев/годов, скрывая работу с подстроками\n3. Получать названия месяцев на заданном языке\n4. Метод *to_string*, который возвращает строковое представление даты по заданной маске *(like printf)*\n\n## Реализация:\n\nСоздаём класс. В его свойствах будем хранить:\n\n1. Язык, который будет передаваться в конструкторе — (по умолчанию — язык системы)\n2. Дата, которая аналогично будет передаваться в конструкторе — (по умолчанию — текущая)\n3. Таблица названий месяцев для выбранного пользователем языка\n4. Константы для метода to_string( )\n\n```abap\n  DATA:\n    gt_month_names TYPE STANDARD TABLE OF t247 .\n  DATA gv_language TYPE lang .\n  DATA gv_date TYPE dats .\n  CONSTANTS nv_long_year TYPE string VALUE '$yyyy'.       \n  CONSTANTS nv_short_year TYPE string VALUE '$yy'.        \n  CONSTANTS nv_month_name TYPE string VALUE '$m'.         \n  CONSTANTS nv_short_month_name TYPE string VALUE '$mmm'. \n  CONSTANTS nv_month_number TYPE string VALUE '$mm'.      \n  CONSTANTS nv_day TYPE string VALUE '$dd'.               \n```\n\n**Конструктор и статический метод create**\n\n```abap\n  \" Просто присваиваем значения \n  METHOD constructor.\n    gv_language = iv_language.\n    gv_date = iv_date.\n  ENDMETHOD.\n\n  METHOD create. \" Что-то отдалённо похожее на фабричный метод,\n  \" только возвращаем инстанс самого класса zcl_date. \n  \" Таким образом избавляемся от громоздкой конструкции create object*\n  \n    CREATE OBJECT ro_instance\n      EXPORTING\n        iv_date     = iv_date\n        iv_language = iv_language.\n  ENDMETHOD.\n```\n\nПрибавлять и вычитать будем уже известным функциональным модулем *RP_CALC_DATE_IN_INTERVAL*, но спрячем его поглубже, чтобы не было так страшно. Наружу (public) будут торчать два минималистичных метода: plus/minus\n\n```abap\n  METHOD date_calculation.\n    CALL FUNCTION 'RP_CALC_DATE_IN_INTERVAL'\n      EXPORTING\n        date      = gv_date\n        days      = iv_days\n        months    = iv_months\n        signum    = iv_sign\n        years     = iv_years\n      IMPORTING\n        calc_date = gv_date.\n  ENDMETHOD.\n\n  METHOD minus.\n    date_calculation( iv_days   = iv_days\n                      iv_months = iv_months\n                      iv_years  = iv_years\n                      iv_sign   = '-' ).\n  ENDMETHOD.\n\n  METHOD plus.\n    date_calculation( iv_days   = iv_days\n                      iv_months = iv_months\n                      iv_years  = iv_years\n                      iv_sign   = '+' ).\n  ENDMETHOD.\n```\n\nПолучать названия месяцев на текущем языке будем с помощью ФМ *MONTH_NAMES_GET*, который будем дёргать тогда, когда осознаем, что для этого языка у нас нет названий.\n\n```abap\n  METHOD init_month_names.\n    CALL FUNCTION 'MONTH_NAMES_GET'\n      EXPORTING\n        language              = gv_language\n      TABLES\n        month_names           = gt_month_names\n      EXCEPTIONS\n        month_names_not_found = 1\n        OTHERS                = 2.\n  ENDMETHOD.\n\n  METHOD get_month_name_by_number.\n    DATA ls_month LIKE LINE OF gt_month_names.\n  \n    \" Есть ли вообще записи для текущего языка?\n    READ TABLE gt_month_names\n      INTO ls_month\n      WITH KEY spras = gv_language.\n  \n    IF sy-subrc <> 0.\n      init_month_names( ).\n    ENDIF.\n  \n    CLEAR ls_month.\n    READ TABLE gt_month_names\n      INTO ls_month\n      WITH KEY\n        mnr   = iv_number\n        spras = gv_language.\n  \n    rv_month_name = ls_month-ltx.\n  ENDMETHOD.\n```\n\nНу и метод to_string( ). Который заменяет ключевые слова в маске значениями.\n\n```abap\n  METHOD to_string.\n    DATA:\n      lv_day              TYPE num2,\n      lv_month_name       TYPE string,\n      lv_month_number     TYPE num2,\n      lv_short_month_name TYPE string,\n      lv_short_year       TYPE num2,\n      lv_long_year        TYPE num4.\n\n    lv_day = get_day( ).\n    lv_month_name = get_month_name( ).\n    lv_month_number = get_month_number( ).\n    lv_short_month_name = get_short_month_name( ).\n    lv_short_year = get_short_year( ).\n    lv_long_year = get_year( ).\n\n    \" year\n    REPLACE ALL OCCURRENCES OF nv_long_year IN iv_format WITH lv_long_year IGNORING CASE.\n    REPLACE ALL OCCURRENCES OF nv_short_year IN iv_format WITH lv_short_year IGNORING CASE.\n\n    \" month\n    REPLACE ALL OCCURRENCES OF nv_short_month_name IN iv_format WITH lv_short_month_name IGNORING CASE.\n    REPLACE ALL OCCURRENCES OF nv_month_number IN iv_format WITH lv_month_number IGNORING CASE.\n    REPLACE ALL OCCURRENCES OF nv_month_name IN iv_format WITH lv_month_name IGNORING CASE.\n\n    \"day\n    REPLACE ALL OCCURRENCES OF nv_day IN iv_format WITH lv_day IGNORING CASE.\n\n    rv_string = iv_format.\n  ENDMETHOD.\n```\n\nОсталось прикрутить геттеры/сеттеры. и доработать API.\n\nЧто в итоге получилось — можно посмотреть здесь: [github.com/JustAddAcid/abap_date](https://github.com/JustAddAcid/abap_date/ \"Класс для удобного использования даты в abap\")\n\n## Результаты\n\n1. Минималистичные методы plus/minus\n\n```abap\nlo_date = zcl_date=>create( '20200101' ). \" 01.01.2020\n\nlo_date->minus( iv_years = 2 ). \" 01.01.2018\nlo_date->plus( iv_days = 3 ).   \"04.01.2018\nlo_date->plus( iv_months = 1 ). \"04.02.2018\n\n\" Несколько аргументов\nlo_date->plus( \n    iv_days  = 1\n    iv_years = 2\n). \" 05.02.2020\n```\n\n2. Геттеры/сеттеры\n3. Метод get_month_name( ), получающий названия месяца\n\n```abap\ndata: lo_date  type ref to zcl_date,\n      lv_dats  type dats,\n      lv_month type string.\n\nlo_date = zcl_date=>create( ).\nlo_date->set_year( 2001 ).\nlo_date->set_month_number( 9 ).\nlo_date->set_day( 11 ).\n\nlv_dats = lo_date->get_date( ).\nlv_month = lo_date->get_month_name( ).\n\nwrite lv_dats. \" 11 сентября 2001\nwrite lv_month. \" Сентябрь\n```\n\n4. Метод to_string( ), возвращающий строковое представление даты по маске\n \n```abap\ndata: lo_date     type ref to zcl_date,\n      lv_formated type string.\n\nlo_date = zcl_date=>create( '20200101' ). \" 01.01.2020\nlv_formated = lo_date->to_string( 'Месяц: $m Год: $yyyy День: $dd' ).\n\nwrite lv_formated. \" Месяц: Январь Год: 2020 День: 01\n```\n\n#abap ","ogImage":{"url":"/assets/blog/zcl_date_abap/cover.png"},"coverImage":"/assets/blog/zcl_date_abap/cover.png","issueId":"8","excerpt":"Надоело страдать с парсингом стандартных типов даты в abap и использовать громоздкие функциональные модули. Написал класс для выполнения рутинных действий в удобном API"}],"tag":"abap"},"__N_SSG":true}