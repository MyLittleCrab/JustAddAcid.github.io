<!DOCTYPE html><html lang="ru"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Nosoff.info — personal blog"/><title>Ищем, в каких таблицах используется домен в ABAP</title><meta property="og:image" content="/assets/blog/domain_where_used_list/background.jpg"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/5ec6f1aaf3f2d08c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5ec6f1aaf3f2d08c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/9f7af63677a5c3f2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9f7af63677a5c3f2.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-3fff476dfb1fd164.js" defer=""></script><script src="/_next/static/chunks/pages/_app-cf1c5e3e9ec7cf41.js" defer=""></script><script src="/_next/static/chunks/782-7188dcd544eb1f2f.js" defer=""></script><script src="/_next/static/chunks/73-601452d0c7a8809f.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-f320750c2f5155dd.js" defer=""></script><script src="/_next/static/ThzsYFI5sOt2OlQR0Zf0Q/_buildManifest.js" defer=""></script><script src="/_next/static/ThzsYFI5sOt2OlQR0Zf0Q/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="min-h-screen"><main><div class="container mx-auto px-5"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/">Nosoff.info</a></h2><article class="mb-32"><h1 class="screenreader">Ищем, в каких таблицах используется домен в ABAP</h1><div class="hidden md:block md:mb-12"><a class="flex items-center" href="https://github.com/JustAddAcid"><img src="https://avatars3.githubusercontent.com/u/21103635?s=120&amp;v=4" class="w-12 h-12 rounded-full mr-4" alt="Roman A. Nosov"/><div class="text-xl font-bold">Roman A. Nosov</div></a></div><div class="mb-8 md:mb-16 -mx-5 sm:mx-0"><div class="-mx-5 sm:mx-0"><img src="/assets/blog/domain_where_used_list/background.jpg" alt="Cover Image for Ищем, в каких таблицах используется домен в ABAP" class="shadow-small"/></div></div><div class="max-w-2xl mx-auto"><div class="block md:hidden mb-6"><a class="flex items-center" href="https://github.com/JustAddAcid"><img src="https://avatars3.githubusercontent.com/u/21103635?s=120&amp;v=4" class="w-12 h-12 rounded-full mr-4" alt="Roman A. Nosov"/><div class="text-xl font-bold">Roman A. Nosov</div></a></div><div class="mb-6 text-lg"><time dateTime="2020-07-12T14:15:07.322Z">July	12, 2020</time></div></div><div class="max-w-2xl mx-auto"><div class="markdown-styles_markdown__h_8de"><p>Какое здесь может быть введение? Продолжаю писать образовательные посты с небольшими вкраплениями абсурда, мемов и ненависти ко всему окружающему. Сегодня пишем утилиту. Под <em>SAP</em>. Своё отношение к разработке на этой платформе высказывал в <a href="./zcl-date-abap">предыдущей статье</a>.</p>
<p>Конкретно эта программа — очень хороший пример, как сама система вынуждает разработчиков усложнять код и делать костыли, чтобы обойти абсолютно <strong>искусственно</strong> расставленные ограничения. Усаживайтесь поудобнее, мы начинаем!</p>
<p><a href="../assets/blog/domain_where_used_list/device.jpg">NSFW MEME about "присаживайтесь"</a></p>
<h2>Немного теории</h2>
<p><strong>Що таке домени в <em>SAP</em>?</strong></p>
<p><strong>Домены в SAP</strong> — это то, что <del>нормальные</del> люди называют <em>типами данных</em>. То, как данные представлены непосредственно в памяти программы или <em>СУБД</em>: строка из N символов, int32, int64, float, enum из определенного набора значений и т.д.</p>
<p>Есть ещё такое понятие в <em>SAP</em>-тусовке как <strong>элемент данных</strong> (<em>data element</em>). Это "тип данных на максималках", который содержит в себе <strong>не только</strong> описание того, как эти данные лежат в памяти, но и дополнительные плюшки в виде:</p>
<ol>
<li>Дефолтный заголовок этого поля для разных языков (который подтягивается в поле ввода или заголовок таблицы по умолчанию)</li>
<li>Ссылка на "средство поиска" — программу, которая помогает пользователю заполнить input значением. (Например, предоставить выбор из списка контрагентов с заданными параметрами)</li>
<li>... прочие второстепенные штуки</li>
</ol>
<p>Т.е. сначала объявляется домен, от него наследуется элемент данных, который уже используется для объявления переменных/объявления столбцов в таблицах БД.</p>
<p><img src="../assets/blog/domain_where_used_list/data_element.jpg" alt="Схема наследования"></p>
<p>Оукей, на первых парах нам этой информации достаточно. Остальное будем понимать по ходу процесса:</p>
<h2>Процесс</h2>
<p><strong>Формулируем</strong>, что мы хотим получить в итоге. Программу, которая:</p>
<ol>
<li>Принимает на вход <strong>имя домена</strong> и параметр:
<ol>
<li>Считать ли количество строк в таблицах</li>
</ol>
</li>
<li>Выводит список таблиц со следующими полями:
<ol>
<li>Имя таблицы, которая использует введенный домен</li>
<li>Название поля таблицы</li>
<li>Имя элемента данных этого поля</li>
<li>Количество строк <strong>или</strong> результат проверки на пустоту (в зависимости от входного параметра) </li>
</ol>
</li>
</ol>
<p>На самом деле, 95% этой задачи решаются очень быстро. Достаточно найти место в базе данных, где хранятся соответствия таблицы -> типа данных -> домена и сделать селект. (Благо, в БД SAP хранится <strong>ВСЁ</strong>, включая программный код)</p>
<p>Методом скоростного гугления обнаруживаем две таблицы, которые нам в этом могут помочь:</p>
<ol>
<li><strong>dd03l</strong> — соответствие: таблица - поле - тип данных - домен</li>
<li><strong>dd02l</strong> — соответствие: таблица - класс таблицы (нас не интересуют объявленные типы таблиц, которые <strong>не</strong> используются в БД)</li>
</ol>
<p>Ну и простейший селект из них:</p>
<pre><code>SELECT DISTINCT dd03l~domname dd03l~rollname dd03l~fieldname
    dd03l~tabname
  INTO CORRESPONDING FIELDS OF TABLE rt_tables
  FROM dd03l JOIN dd02l
    ON dd03l~tabname = dd02l~tabname AND
      dd03l~as4local = dd02l~as4local
  WHERE
    dd03l~domname IN ir_domains AND
    " Активные
    dd03l~as4local = 'A' AND
    " Таблицы, которые используются в СУБД
    dd02l~tabclass IN ('TRANSP', 'CLUSTER', 'POOL').
</code></pre>
<p>Проверка количества записей делается самым очевидным способом: <strong>select count(*)</strong> в цикле по всем таблицам.</p>
<pre><code>LOOP AT lt_tables ASSIGNING &#x3C;ls_table>.
  SELECT SINGLE COUNT(*)
    FROM (&#x3C;ls_table>-tabname)
    INTO lv_records_count.

  " [ .... ]
ENDLOOP.
</code></pre>
<p>Казалось бы, что может пойти не так? Всего лишь осталось реализовать проверку таблицы на пустоту, не делая select count(*) по всей таблице. </p>
<p>Поскольку за выполнение запросов напрямую в <strong>БД</strong>, минуя прослойку <strong>ABAP</strong> — абаперов бьют по рукам (особенно при миграции на другую <em>СУБД</em>). Разработчикам приходится довольствоваться куцым подмножеством <strong>sql</strong>, который предоставляет ABAP API. В нём напрочь отсутствует не только <em>database-specific-features</em>, но и вполне стандартные вещи типа вложенных запросов.</p>
<p>Т.е. вот такой простой и понятный запрос у нас ни за что не выполнится:</p>
<pre><code>select count(*) 
from (select top 1 * 
      from TABLE)
</code></pre>
<p>Приходится изобретать велосипед. И единственным выходом в этой ситуации будет попытка сделать селект <strong>хотя бы одной</strong> записи из таблицы и проверка на успех.</p>
<p>Сказано-сделано:</p>
<pre><code>LOOP AT lt_tables ASSIGNING &#x3C;ls_table>.
  SELECT SINGLE *
    FROM (&#x3C;ls_table>-tabname)
    INTO " ...
  " Так, стоп. А куда присваивать значение?
  " [ .... ]
ENDLOOP.
</code></pre>
<p>Блок <strong>into %var%</strong> пропустить нельзя. Без него компиллятор сваливается с ошибкой. (Про ABAP-подобие байткода как-нибудь в другой раз)</p>
<p>А куда присваивать значения, если заранее неизвестен тип данных? В <strong>ABAP</strong> таких "безразмерных" типов нет. Так что придется как-то объявлять переменные в рантайме. Но с этим не всё так гладко! :)</p>
<h2>Длинное отступление про принцип объявления переменных в ABAP</h2>
<p>Казалось бы, о чем здесь рассказывать? Почти каждый относительно-высокоуровневый язык предоставляет очень простой <em>API</em> для объявления переменных. </p>
<p>В данном случае, переменные объявляются ключевым словом <strong>DATA</strong>, далее идет указание имени переменной и её тип:</p>
<pre><code>data some_name type string.
</code></pre>
<p>Но, поскольку <em>abap</em> — достаточно старый язык, он тянет за собой весьма странное легаси-поведение, которое в современном мире кажется моветоном. Например:</p>
<pre><code>if 1 = 1.
    data some_string type string.
    some_string = 'hello world'.
endif.

write some_string.
</code></pre>
<p>Уважаемые знатоки, внимание вопрос: выполнится ли этот код без ошибки? И выведется ли <em>hello world?</em>
Правильные ответы: <strong>да и да</strong>.</p>
<p>Если вы на секунду подумали, что объявление переменных в <em>abap</em> ведет себя так же, как ключевое слово <strong>var</strong> в <em>JavaScript</em>, и переменная <em>"вываливается"</em> за текущий блок, то спешу вас разочаровать... </p>
<pre><code>if 1 = 2.
    " Никогда не выполнится
    data some_string type string.
endif.

some_string = 'hello world'.
write some_string. "hello world 
"(да, это работает)
</code></pre>
<p>Несмотря на то, что выполнение основного интерпретатора программы <strong>никогда</strong> не зайдёт в блок <strong>IF</strong>, переменная всё равно объявится!</p>
<p><strong>N.B.</strong>: перед выполнением кода, его быстренько пробегает интерпретатор и выделяет память под <strong>все</strong> используемые переменные в этой подпрограмме/методе.</p>
<p>А объявленные переменные будут доступны в <strong>любом месте</strong> внутри метода/подпрограммы.</p>
<p>На самом деле, это больше похоже на хостинг функций в <em>JavaScript</em>. <a href="https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5">Который хорошо описан здесь.</a></p>
<p>Значит ли это, <del>что всё предопределено</del> что мы не можем выделять память в рантайме, когда на момент компилляции неизвестен тип? </p>
<p>И да, и нет. Саму переменную всё-таки придется объявить в виде ссылки на "какую-то" область памяти. А под неё уточнить тип и выделить память мы можем тогда, когда нам это потребуется. Выглядит это следующим образом:</p>
<pre><code>" Создаём переменную как ссылку на "какие-то" данные
data my_var type ref to data.
" Выделяем память под нужный тип данных
create data my_var type ('typename').
</code></pre>
<p>Это, конечно, прекрасно. Но так просто обращаться к этой области памяти и записывать/читать данные у нас не получится! :) Для этого нам потребуется познакомиться с ещё одним abap-концептом.</p>
<p>Это <strong>field-symbols</strong> — ссылки на уже <strong>объявленные</strong> переменные или строки таблицы. В примерах выше, где я делал цикл по таблице, я уже использовал <em>field-symbol</em>, куда присваивал адрес "текущей" строки в итерации цикла.</p>
<pre><code>loop at table assigning &#x3C;field-symbol>.
" do some shit with &#x3C;field-symbol>
endloop.
</code></pre>
<p>Аналогичное действие придется выполнить и сейчас, чтобы полноценно воспользоваться выделенной памятью, как переменной:</p>
<pre><code>data my_var type ref to data.
" field-symbol можно объявлять с типом any
field-symbols &#x3C;link_to_data> type any.

create data my_var type ('typename').
assign my_var->* to &#x3C;link_to_data>.

" do some shit with &#x3C;link_to_data>
</code></pre>
<h2>Финишная прямая:</h2>
<p>Прикручиваем эти концепты к нашей задаче:</p>
<pre><code>FIELD-SYMBOLS: &#x3C;lv_temp>  TYPE ANY.
DATA lo_data TYPE REF TO data.

LOOP AT it_tables ASSIGNING &#x3C;ls_table>.
  
  CREATE DATA lo_data TYPE (&#x3C;ls_table>-rollname).
  ASSIGN lo_data->* TO &#x3C;lv_temp>.

  SELECT SINGLE (&#x3C;ls_table>-fieldname)
    FROM (&#x3C;ls_table>-tabname)
    INTO &#x3C;lv_temp>.

  "sy-subrc аналог return-code в bash
  IF sy-subrc = 0.
    " Обработка успешного селекта
  ELSE.
    " Обработка пустой таблицы
  ENDIF.
ENDLOOP.
</code></pre>
<h2>Заключение</h2>
<p>Внезапно этот костыль компилируется и работает. За очисткой данных можно не следить, т.к. за нас её выполнит сборщик мусора. Нам остаётся красиво нарисовать результаты пользователю, но это уже совсем другая история.</p>
<p>Вот именно таким образом тривиальные задачи усложняются внутри abap во много раз из-за излишних синтаксических ограничений. </p>
<p>Например, если бы было возможно выполнить вложенный <em>sql</em> или исключить блок "into" в запросах, то не пришлось бы в цикле выделять много памяти под абсолютно ненужную переменную, которая никак не обрабатывается в дальнейшем. </p>
<p>(Кстати, создавая потенциальную утечку памяти, т.к. никто не знает, насколько качественно отрабатывает сборщик мусора)</p>
<p>На этом всё. Всех благ. :)</p>
<p><a href="/tags/abap">#abap</a></p>
</div></div></article><article class="mb-32 max-w-2xl mx-auto"><hr class="mb-5"/><h2 class="text-2xl md:text-2xl lg:text-2xl font-bold tracking-tighter leading-tight md:leading-none mb-12 text-center md:text-center">Комментарии</h2><div class="md:flex p-6">Loading...</div><a href="https://github.com/JustAddAcid/JustAddAcid.github.io/issues/13" class="bg-white hover:bg-gray-100 text-gray-800 font-semibold py-2 px-4 border border-gray-400 rounded shadow mt-2 inline-block">Добавить комментарий</a></article></div></main></div><footer class="bg-accent-1 border-t border-accent-2"><div class="container mx-auto px-5"></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Ищем, в каких таблицах используется домен в ABAP","date":"2020-07-12T14:15:07.322Z","slug":"domain_where_used_list","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120\u0026v=4","url":"https://github.com/JustAddAcid"},"content":"\u003cp\u003eКакое здесь может быть введение? Продолжаю писать образовательные посты с небольшими вкраплениями абсурда, мемов и ненависти ко всему окружающему. Сегодня пишем утилиту. Под \u003cem\u003eSAP\u003c/em\u003e. Своё отношение к разработке на этой платформе высказывал в \u003ca href=\"./zcl-date-abap\"\u003eпредыдущей статье\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eКонкретно эта программа — очень хороший пример, как сама система вынуждает разработчиков усложнять код и делать костыли, чтобы обойти абсолютно \u003cstrong\u003eискусственно\u003c/strong\u003e расставленные ограничения. Усаживайтесь поудобнее, мы начинаем!\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"../assets/blog/domain_where_used_list/device.jpg\"\u003eNSFW MEME about \"присаживайтесь\"\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eНемного теории\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eЩо таке домени в \u003cem\u003eSAP\u003c/em\u003e?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eДомены в SAP\u003c/strong\u003e — это то, что \u003cdel\u003eнормальные\u003c/del\u003e люди называют \u003cem\u003eтипами данных\u003c/em\u003e. То, как данные представлены непосредственно в памяти программы или \u003cem\u003eСУБД\u003c/em\u003e: строка из N символов, int32, int64, float, enum из определенного набора значений и т.д.\u003c/p\u003e\n\u003cp\u003eЕсть ещё такое понятие в \u003cem\u003eSAP\u003c/em\u003e-тусовке как \u003cstrong\u003eэлемент данных\u003c/strong\u003e (\u003cem\u003edata element\u003c/em\u003e). Это \"тип данных на максималках\", который содержит в себе \u003cstrong\u003eне только\u003c/strong\u003e описание того, как эти данные лежат в памяти, но и дополнительные плюшки в виде:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eДефолтный заголовок этого поля для разных языков (который подтягивается в поле ввода или заголовок таблицы по умолчанию)\u003c/li\u003e\n\u003cli\u003eСсылка на \"средство поиска\" — программу, которая помогает пользователю заполнить input значением. (Например, предоставить выбор из списка контрагентов с заданными параметрами)\u003c/li\u003e\n\u003cli\u003e... прочие второстепенные штуки\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eТ.е. сначала объявляется домен, от него наследуется элемент данных, который уже используется для объявления переменных/объявления столбцов в таблицах БД.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"../assets/blog/domain_where_used_list/data_element.jpg\" alt=\"Схема наследования\"\u003e\u003c/p\u003e\n\u003cp\u003eОукей, на первых парах нам этой информации достаточно. Остальное будем понимать по ходу процесса:\u003c/p\u003e\n\u003ch2\u003eПроцесс\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eФормулируем\u003c/strong\u003e, что мы хотим получить в итоге. Программу, которая:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eПринимает на вход \u003cstrong\u003eимя домена\u003c/strong\u003e и параметр:\n\u003col\u003e\n\u003cli\u003eСчитать ли количество строк в таблицах\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eВыводит список таблиц со следующими полями:\n\u003col\u003e\n\u003cli\u003eИмя таблицы, которая использует введенный домен\u003c/li\u003e\n\u003cli\u003eНазвание поля таблицы\u003c/li\u003e\n\u003cli\u003eИмя элемента данных этого поля\u003c/li\u003e\n\u003cli\u003eКоличество строк \u003cstrong\u003eили\u003c/strong\u003e результат проверки на пустоту (в зависимости от входного параметра) \u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eНа самом деле, 95% этой задачи решаются очень быстро. Достаточно найти место в базе данных, где хранятся соответствия таблицы -\u003e типа данных -\u003e домена и сделать селект. (Благо, в БД SAP хранится \u003cstrong\u003eВСЁ\u003c/strong\u003e, включая программный код)\u003c/p\u003e\n\u003cp\u003eМетодом скоростного гугления обнаруживаем две таблицы, которые нам в этом могут помочь:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003edd03l\u003c/strong\u003e — соответствие: таблица - поле - тип данных - домен\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edd02l\u003c/strong\u003e — соответствие: таблица - класс таблицы (нас не интересуют объявленные типы таблиц, которые \u003cstrong\u003eне\u003c/strong\u003e используются в БД)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eНу и простейший селект из них:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSELECT DISTINCT dd03l~domname dd03l~rollname dd03l~fieldname\n    dd03l~tabname\n  INTO CORRESPONDING FIELDS OF TABLE rt_tables\n  FROM dd03l JOIN dd02l\n    ON dd03l~tabname = dd02l~tabname AND\n      dd03l~as4local = dd02l~as4local\n  WHERE\n    dd03l~domname IN ir_domains AND\n    \" Активные\n    dd03l~as4local = 'A' AND\n    \" Таблицы, которые используются в СУБД\n    dd02l~tabclass IN ('TRANSP', 'CLUSTER', 'POOL').\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eПроверка количества записей делается самым очевидным способом: \u003cstrong\u003eselect count(*)\u003c/strong\u003e в цикле по всем таблицам.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eLOOP AT lt_tables ASSIGNING \u0026#x3C;ls_table\u003e.\n  SELECT SINGLE COUNT(*)\n    FROM (\u0026#x3C;ls_table\u003e-tabname)\n    INTO lv_records_count.\n\n  \" [ .... ]\nENDLOOP.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eКазалось бы, что может пойти не так? Всего лишь осталось реализовать проверку таблицы на пустоту, не делая select count(*) по всей таблице. \u003c/p\u003e\n\u003cp\u003eПоскольку за выполнение запросов напрямую в \u003cstrong\u003eБД\u003c/strong\u003e, минуя прослойку \u003cstrong\u003eABAP\u003c/strong\u003e — абаперов бьют по рукам (особенно при миграции на другую \u003cem\u003eСУБД\u003c/em\u003e). Разработчикам приходится довольствоваться куцым подмножеством \u003cstrong\u003esql\u003c/strong\u003e, который предоставляет ABAP API. В нём напрочь отсутствует не только \u003cem\u003edatabase-specific-features\u003c/em\u003e, но и вполне стандартные вещи типа вложенных запросов.\u003c/p\u003e\n\u003cp\u003eТ.е. вот такой простой и понятный запрос у нас ни за что не выполнится:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eselect count(*) \nfrom (select top 1 * \n      from TABLE)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eПриходится изобретать велосипед. И единственным выходом в этой ситуации будет попытка сделать селект \u003cstrong\u003eхотя бы одной\u003c/strong\u003e записи из таблицы и проверка на успех.\u003c/p\u003e\n\u003cp\u003eСказано-сделано:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eLOOP AT lt_tables ASSIGNING \u0026#x3C;ls_table\u003e.\n  SELECT SINGLE *\n    FROM (\u0026#x3C;ls_table\u003e-tabname)\n    INTO \" ...\n  \" Так, стоп. А куда присваивать значение?\n  \" [ .... ]\nENDLOOP.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eБлок \u003cstrong\u003einto %var%\u003c/strong\u003e пропустить нельзя. Без него компиллятор сваливается с ошибкой. (Про ABAP-подобие байткода как-нибудь в другой раз)\u003c/p\u003e\n\u003cp\u003eА куда присваивать значения, если заранее неизвестен тип данных? В \u003cstrong\u003eABAP\u003c/strong\u003e таких \"безразмерных\" типов нет. Так что придется как-то объявлять переменные в рантайме. Но с этим не всё так гладко! :)\u003c/p\u003e\n\u003ch2\u003eДлинное отступление про принцип объявления переменных в ABAP\u003c/h2\u003e\n\u003cp\u003eКазалось бы, о чем здесь рассказывать? Почти каждый относительно-высокоуровневый язык предоставляет очень простой \u003cem\u003eAPI\u003c/em\u003e для объявления переменных. \u003c/p\u003e\n\u003cp\u003eВ данном случае, переменные объявляются ключевым словом \u003cstrong\u003eDATA\u003c/strong\u003e, далее идет указание имени переменной и её тип:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edata some_name type string.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eНо, поскольку \u003cem\u003eabap\u003c/em\u003e — достаточно старый язык, он тянет за собой весьма странное легаси-поведение, которое в современном мире кажется моветоном. Например:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif 1 = 1.\n    data some_string type string.\n    some_string = 'hello world'.\nendif.\n\nwrite some_string.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eУважаемые знатоки, внимание вопрос: выполнится ли этот код без ошибки? И выведется ли \u003cem\u003ehello world?\u003c/em\u003e\nПравильные ответы: \u003cstrong\u003eда и да\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eЕсли вы на секунду подумали, что объявление переменных в \u003cem\u003eabap\u003c/em\u003e ведет себя так же, как ключевое слово \u003cstrong\u003evar\u003c/strong\u003e в \u003cem\u003eJavaScript\u003c/em\u003e, и переменная \u003cem\u003e\"вываливается\"\u003c/em\u003e за текущий блок, то спешу вас разочаровать... \u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif 1 = 2.\n    \" Никогда не выполнится\n    data some_string type string.\nendif.\n\nsome_string = 'hello world'.\nwrite some_string. \"hello world \n\"(да, это работает)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eНесмотря на то, что выполнение основного интерпретатора программы \u003cstrong\u003eникогда\u003c/strong\u003e не зайдёт в блок \u003cstrong\u003eIF\u003c/strong\u003e, переменная всё равно объявится!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eN.B.\u003c/strong\u003e: перед выполнением кода, его быстренько пробегает интерпретатор и выделяет память под \u003cstrong\u003eвсе\u003c/strong\u003e используемые переменные в этой подпрограмме/методе.\u003c/p\u003e\n\u003cp\u003eА объявленные переменные будут доступны в \u003cstrong\u003eлюбом месте\u003c/strong\u003e внутри метода/подпрограммы.\u003c/p\u003e\n\u003cp\u003eНа самом деле, это больше похоже на хостинг функций в \u003cem\u003eJavaScript\u003c/em\u003e. \u003ca href=\"https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5\"\u003eКоторый хорошо описан здесь.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eЗначит ли это, \u003cdel\u003eчто всё предопределено\u003c/del\u003e что мы не можем выделять память в рантайме, когда на момент компилляции неизвестен тип? \u003c/p\u003e\n\u003cp\u003eИ да, и нет. Саму переменную всё-таки придется объявить в виде ссылки на \"какую-то\" область памяти. А под неё уточнить тип и выделить память мы можем тогда, когда нам это потребуется. Выглядит это следующим образом:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\" Создаём переменную как ссылку на \"какие-то\" данные\ndata my_var type ref to data.\n\" Выделяем память под нужный тип данных\ncreate data my_var type ('typename').\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eЭто, конечно, прекрасно. Но так просто обращаться к этой области памяти и записывать/читать данные у нас не получится! :) Для этого нам потребуется познакомиться с ещё одним abap-концептом.\u003c/p\u003e\n\u003cp\u003eЭто \u003cstrong\u003efield-symbols\u003c/strong\u003e — ссылки на уже \u003cstrong\u003eобъявленные\u003c/strong\u003e переменные или строки таблицы. В примерах выше, где я делал цикл по таблице, я уже использовал \u003cem\u003efield-symbol\u003c/em\u003e, куда присваивал адрес \"текущей\" строки в итерации цикла.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eloop at table assigning \u0026#x3C;field-symbol\u003e.\n\" do some shit with \u0026#x3C;field-symbol\u003e\nendloop.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eАналогичное действие придется выполнить и сейчас, чтобы полноценно воспользоваться выделенной памятью, как переменной:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edata my_var type ref to data.\n\" field-symbol можно объявлять с типом any\nfield-symbols \u0026#x3C;link_to_data\u003e type any.\n\ncreate data my_var type ('typename').\nassign my_var-\u003e* to \u0026#x3C;link_to_data\u003e.\n\n\" do some shit with \u0026#x3C;link_to_data\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eФинишная прямая:\u003c/h2\u003e\n\u003cp\u003eПрикручиваем эти концепты к нашей задаче:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFIELD-SYMBOLS: \u0026#x3C;lv_temp\u003e  TYPE ANY.\nDATA lo_data TYPE REF TO data.\n\nLOOP AT it_tables ASSIGNING \u0026#x3C;ls_table\u003e.\n  \n  CREATE DATA lo_data TYPE (\u0026#x3C;ls_table\u003e-rollname).\n  ASSIGN lo_data-\u003e* TO \u0026#x3C;lv_temp\u003e.\n\n  SELECT SINGLE (\u0026#x3C;ls_table\u003e-fieldname)\n    FROM (\u0026#x3C;ls_table\u003e-tabname)\n    INTO \u0026#x3C;lv_temp\u003e.\n\n  \"sy-subrc аналог return-code в bash\n  IF sy-subrc = 0.\n    \" Обработка успешного селекта\n  ELSE.\n    \" Обработка пустой таблицы\n  ENDIF.\nENDLOOP.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eЗаключение\u003c/h2\u003e\n\u003cp\u003eВнезапно этот костыль компилируется и работает. За очисткой данных можно не следить, т.к. за нас её выполнит сборщик мусора. Нам остаётся красиво нарисовать результаты пользователю, но это уже совсем другая история.\u003c/p\u003e\n\u003cp\u003eВот именно таким образом тривиальные задачи усложняются внутри abap во много раз из-за излишних синтаксических ограничений. \u003c/p\u003e\n\u003cp\u003eНапример, если бы было возможно выполнить вложенный \u003cem\u003esql\u003c/em\u003e или исключить блок \"into\" в запросах, то не пришлось бы в цикле выделять много памяти под абсолютно ненужную переменную, которая никак не обрабатывается в дальнейшем. \u003c/p\u003e\n\u003cp\u003e(Кстати, создавая потенциальную утечку памяти, т.к. никто не знает, насколько качественно отрабатывает сборщик мусора)\u003c/p\u003e\n\u003cp\u003eНа этом всё. Всех благ. :)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/tags/abap\"\u003e#abap\u003c/a\u003e\u003c/p\u003e\n","ogImage":{"url":"/assets/blog/domain_where_used_list/background.jpg"},"coverImage":"/assets/blog/domain_where_used_list/background.jpg","issueId":"13"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"domain_where_used_list"},"buildId":"ThzsYFI5sOt2OlQR0Zf0Q","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>