{"pageProps":{"allPosts":[{"title":"Автоматизируем деплой статического сайта с помощью CircleCI","date":"2020-05-05T16:12:07.322Z","slug":"circle-ci","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120&v=4","url":"https://github.com/JustAddAcid"},"content":"\nС хостингом и комментариями немного разобрались. Теперь заставим нашу шайтан-машину автоматически пересобирать сайт, если в .md шаблонах произошли какие-то изменения. Потому что нет никакого желания **каждый раз** после минимального изменения статьи делать руками билд, перетаскивать собранные *html* страницы в другой репозиторий и коммитить. Естественно, это можно и нужно оптимизировать. В качестве подопытного кролика сегодня выступает сервис *CircleCi*, у которого достаточно удобный бесплатный тариф, которого нам будет более чем достаточно.\n\n**Для тех, кто в танке и никогда об этом не слышал:** *CircleCi* — это облачный сервис для continuous integration. Умеет следить за изменениями в Git-репозиториях и пересобирать билды приложений, прогонять тесты и т.д. Тестить в статическом блоге толком нечего, а вот функция собирать билды нам как раз пригодится.\n\n**Для бородатых админов:** я не большой спец в CI, так что, если код будет не совсем согласован с общепринятыми Best-Practice, то прошу меня извинить и прошу написать в комментариях о том, как это сделать лучше и безопасней.\n\n## Автоматизировали, автоматизировали, да не выавтоматизировали\n![If you never deploy, your deploy never falls](../public/assets/blog/circleci/meme.jpeg)\n\nИтак, поехали. Для начала, нужно определиться, что за нас должна делать шайтан-машина. \nПредварительный алгоритм:\n\n1. Скрипт проверяет все .md файлы с постами на предмет того, создана ли для него issue на GitHub (для реализации комментариев, [о которых здесь](./issue-comments-github))\n2. Если к .md файлу не привязана issue, то создать, и записать в файл issue id. Сделать коммит и пуш\n3. Сделать билд в статический html\n4. Положить файлы билда в репозиторий с github pages (JustAddAcid.github.io). Сделать коммит и пуш\n\n## Реализация — скрипт проверки и привязки issue\nВ package.json объявим скрипт issues, который запускает файл issues.mjs из корня. \n\n```javascript\n{\n  \"scripts\": {\n    \"dev\": \"next\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"export\": \"next export\",\n    \"issues\": \"node issues.mjs\" //  <--- \n  }\n}\n```\nВ issues.mjs следующая логика: во всех файлах с постами скрипт ищет подстроку %%ISSUЕ_ID%%. И если находит, то создаёт новое GitHub Issue, а его ID подставляет вместо %%ISSUЕ_ID%%.\n```javascript\nconst issueNotCreatedYet = '%%ISSUЕ_ID%%',\n      notCreatedRegExp = new RegExp(issueNotCreatedYet, 'g')\n\n//...\n\nconst main = async () => {\n\n    const filesInDir = fs.readdirSync(postsDir) // получаем имена файлов в директории\n    \n    for (const fileName of filesInDir){\n        const filePath = postsDir + '/' + fileName,\n              fileText = fs.readFileSync(filePath).toString(),\n              nameWithoutExtension = fileName.split('.')[0]\n    \n        if (fileText.includes(issueNotCreatedYet)){ \n            const issueId = await createIssue(nameWithoutExtension),\n                  newText = fileText.replace(notCreatedRegExp, issueId)\n            fs.writeFileSync(filePath, newText);\n        }\n    \n    }\n}\n```\nА функция, createIssue представляет собой post-запрос в github api\n```javascript\nconst createIssue = async name => {\n    const url = `https://api.github.com/repos/${githubUser}/${targetRepo}/issues`\n    const response = await fetch(url, {\n        method: 'post',\n        body: JSON.stringify({\n            title: 'Comments: ' + name,\n            body: postPrefix + name\n        }),\n        headers: {\n            'Accept' : 'application/vnd.github.v3.html+json',\n            'Content-Type': 'application/json',\n            'Authorization': basicAuthHeader(githubUser, password) \n        }\n    })\n    const createdIssue = await response.json();\n    return createdIssue.number.toString();\n}\n```\n\n*В примере выше для авторизации на GitHub используется basic auth header, который сейчас является **deprecated**. Такая возможность авторизоваться будет **удалена** в ноябре 2020. [Больше информации здесь.](https://developer.github.com/changes/2020-02-14-deprecating-password-auth/ \"Deprecating password authentication\")*\n\nТеперь мне нужно запомнить, что всегда, когда я хочу, чтобы система автоматически создала issue, нужно вместо ID созданной руками issue писать директиву %%ISSUЕ_ID%%\n```javascript\n{\n    excerpt: 'С хостингом и комментариями немного разобрались. Теперь заставим нашу шайтан-машину пересобирать сайт, если в .md шаблонах произошли какие-то изменения'\n    coverImage: '/assets/blog/circleci/cover.png'\n    date: '2020-05-05T16:12:07.322Z'\n    issueId: '%%ISSUЕ_ID%%'\n}\n```\n\n\n## Реализация — конфиг CircleCi\nКонфиг *CircleCi* представляет собой **config.yml** файл в директории **.circleci** в корне вашего репозитория. Сам конфиг-файл содержит описания шагов, которые должен сделать сервер, чтобы задеплоить ваше приложение и/или запустить тесты. \n\nНо для начала нужно примерно представить, какие действия (shell-команды) нам всё-таки нужно проделать. У меня получилось как-то так:\n\n```bash\n# Представляемся гиту\ngit config --global user.email $GH_EMAIL\ngit config --global user.name $CIRCLE_USERNAME\n\n# Запускаем скрипт проверки issues\nnpm run issues\nif [[ `git status --porcelain` ]]; then\n  # Если мы изменили какие-то файлы — делаем коммит. \n  # А деплой будем делать в следующем таске, которые запустится при коммите\n  git add -A\n  git commit -m \"Automated issues creation: ${CIRCLE_SHA1}\"\n  git push\n  echo \"Pushed changes in current repo. Deploy in next task\"\n  circleci-agent step halt\nfi\n\nnpm run build\n\n# Клонируем репозиторий сайта во временную папку и удаляем лишние директории\ngit clone $TARGET_REPO_URL targetDirectory\ncd ./targetDirectory/\nrm -rf ./_next\nrm -rf ./assets\nrm -rf ./favicon\nrm -rf ./posts\necho \"deleting folders from $PWD\"\ncd ..\n# Инициируем экспорт проекта в статические html\nnpm run export\n# Перекладываем html в наш репозиторий с сайтом\n/bin/cp ./out/* ./targetDirectory/ -R -f\ncd ./targetDirectory/\necho \"commit in dir $PWD into $TARGET_REPO_URL repo\"\ngit add -A\ngit commit -m \"Automated deployment to GitHub Pages: ${CIRCLE_SHA1}\" --allow-empty\ngit push\n```\n\nОсталось натянуть этот скрипт на конфиг **CircleCi**:\nСоздаём в репозитории директорию **.circleci**, в ней файл **config.yml** с примерно следующим содержанием:\n```yaml\nversion: 2.1\njobs:\n  build:\n    docker:\n      - image: circleci/node:latest\n    steps:\n      - checkout\n      - restore_cache:\n          keys:\n            - v1-dependencies-\n            - v1-dependencies-\n      - run:\n          name: Install dependencies\n          command: npm install\n      - save_cache:\n          paths:\n            - node_modules\n          key: v1-dependencies-\n      - deploy:\n          name: Deploy\n          command: |\n            git config --global user.email $GH_EMAIL\n            git config --global user.name $CIRCLE_USERNAME\n\n            # .... тот shell-скрипт, который представлен выше\n```\nОстались мелочи:\n\n1. Зайти на сайт #CircleCi, залогинившись своим аккаунтом GitHub\n2. Во вкладке projects выбрать нужный репозиторий\n3. Передать все используемые в скриптах переменные окружения\n4. Создать user-key (для возможности коммита в репозиторий)\n\n\nВ итоге, при каждом коммите в репозиторий будет просыпаться скрипт в CircleCi и пересобирать статический блог.\n\nЕщё увидимся.\n\n#javascript #bash ","ogImage":{"url":"/assets/blog/circleci/cover.png"},"coverImage":"/assets/blog/circleci/cover.png","issueId":"7","excerpt":"С хостингом и комментариями немного разобрались. Теперь заставим нашу шайтан-машину пересобирать сайт, если в .md шаблонах произошли какие-то изменения"}],"tag":"CircleCi"},"__N_SSG":true}