{"pageProps":{"allPosts":[{"title":"Подключаем сторонние шрифты с иконками к SAPUI5-приложению","date":"2020-09-26T17:08:30.259Z","slug":"sapui5-connect-icons-font","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120&v=4","url":"https://github.com/JustAddAcid"},"content":"\nПривет, мои маленькие любители лёгкого *БДСМ*. В эфире передача \"веселые истории с *SAPUI5*\". И сегодня мы рассмотрим, какие шаги нужно проделать, чтобы подключить шрифт с нужными нам иконками и использовать их при построении интерфейса. Тому що список стандартных иконок очень куцый, и иногда нужно добавить что-нибудь со стороны.\n\nКак и всегда это бывает в айтишечке, мы можем решить эту задачу целыми *двумя* способами:\n\n**Первый** — найти нормальную работу, и не маяться ерундой.\n\n![Нормальная работа](../public/assets/blog/sapui5-connect-icons-font/work_meme.jpg)\n\n**Второй** (сложнее, но не сильно) — описан ниже.\n\n## Немного теории\n\nНа [официальном демо-примере](https://sapui5.hana.ondemand.com/#/entity/sap.ui.core.Icon/sample/sap.ui.core.sample.Icon) можем посмотреть как работают нативные иконки в этом фреймворке. \n\nС точки зрения кода, иконки представлены классом sap.ui.core.**Icon**, остальные элементы экрана, в которых есть иконки, либо расширяют этот класс, либо содержат его внутри себя. Его конструктор принимает следующие основные аргументы:\n\n```xml\n<core:Icon\n  src=\"sap-icon://syringe\" путь до иконки с протоколом sap-icon\n  color=\"#031E48\" > цвет\n</core:Icon>\n```\n\nИ всё это чудо преобразовывается в следующую конструкцию при запуске:\n\n```html\n<span \n  role=\"presentation\" \n  aria-hidden=\"true\" \n  aria-label=\"syringe\" \n  data-sap-ui-icon-content=\"\" \n  class=\"sapUiIcon sapUiIconMirrorInRTL\" \n  style=\"font-family: 'SAP\\2dicons'; color: #031E48;\">\n  ::before\n</span>\n```\n\n*SPAN*, в котором в аттрибуте style явно объявлен нативный шрифт с иконками, и цвет, заданный в XML-конструкторе. Сам символ иконки лежит в аттрибуте *data-sap-ui-icon-content*, который с помощью *css* подставляется внутрь псеводэлемента *::before*:\n\n```css\n.sapUiIcon::before{\n  content: attr(data-sap-ui-icon-content);\n  speak: none;\n  font-weight: normal;\n}\n```\n\nЗачем я это написал? Непонятно, т.к. в этой информации нет ничего полезного. \n\n![Для общего развития](../public/assets/blog/sapui5-connect-icons-font/для%20общего%20развития.jpg)\n\nПервым делом делаем что? Праавильно! [Лезем в доку](https://help.sap.com/saphelp_uiaddon10/helpdata/en/21/ea0ea94614480d9a910b2e93431291/content.htm?no_cache=true), где индусским по белому написано, что для использования кастомных шрифтов иконок нужно сделать несколько очень простых телодвижений:\n\n1. Объявить *font-face* с нашими шрифтами в *css*\n2. **Каждую** иконку, которую мы хотим использовать, нужно объявить с помощью метода sap.ui.core.IconPool.**addIcon**(iconName, collectionName, fontFamily, content)\n3. Ссылаться в на объявленные иконки во всех местах, где очень чешется по следующему принципу: **sap-icon**://\\[**collection-name**\\]/\\[**icon-name**\\]\n\nНа этом можно было заканчивать, но давайте пример.\n\n## Пример\n\nДля начала нам нужен какой-нибудь шрифт с иконками. Можно запаковать любые свои векторные изображения в шрифт, если очень хочется. Благо, для этого существует бесконечное количество утилит. Гуглите. \n\nЯ для примера буду пользовать готовую сборку иконок от [fontawesome](https://fontawesome.com). Залезаем, качаем архив с исходниками. В бесплатной версии нам доступны только шрифты: **brands**, **regular**, **solid**.\n\nВ директории */webfonts* собраны эти три шрифта в разных форматах. (Чтобы покрыть все популярные браузеры) -> Копируем эту директорию в корень нашего проекта. \n\nДалее, идем по официальной инструкции:\n\nЧтобы объявить шрифты из *fontawesome* нужно с каждым из его шрифтов провернуть следующее:\n\n **Лезем в css проекта**.\n\n 1. Если нет .css файлов — создаём и объявляем его в manifest.json.\n   Путь объявления в манифесте:\n   ```JavaScript\n   {\n     \"sap.ui5\": {\n       \"resources\": {\n         \"css\": [\n           {\n             \"uri\": \"css/yourfilename.css\"\n           }\n         ]\n       }\n     }\n   }\n   ```\n 2. **Смотрим в файл** fontawesome/%fontname%.css\n 3. **Копируем блок** **@font-face**, в *css* проекта. Который будет примерно следующим:\n ```css\n @font-face {\n   font-family: 'Font Awesome 5 Free';\n   font-style: normal;\n   font-weight: 900;\n   font-display: block;\n   src: url(\"../webfonts/fa-solid-900.eot\");\n   src: url(\"../webfonts/fa-solid-900.eot?#iefix\") format(\"embedded-opentype\"), url(\"../webfonts/fa-solid-900.woff2\") format(\"woff2\"), url(\"../webfonts/fa-solid-900.woff\") format(\"woff\"), url(\"../webfonts/fa-solid-900.ttf\") format(\"truetype\"), url(\"../webfonts/fa-solid-900.svg#fontawesome\") format(\"svg\"); }\n ```\n 4. Где-нибудь в коде (например, при инициализации Component.js, и *желательно* в отдельном файле) добавляем нужные нам иконки в пул:\n ```JavaScript\n sap.ui.core.IconPool.addIcon(\"angry\", \"fa\", \"Font Awesome 5 Free\", \"f556\");\n sap.ui.core.IconPool.addIcon(\"gem\", \"fa\", \"Font Awesome 5 Free\", \"f3a5\");\n //...\n ```\n (Названия иконок и их символьные коды можно [подсмотреть на сайте](https://fontawesome.com/icons/gem?style=regular).)\n  \n 5. Используем иконки при декларации каких-нибудь элементов экрана:\n ```xml\n <Button text=\"Очень красивая кнопка\"\n     icon=\"sap-icon://fa/gem\" />\n ```\n\n![Очень красивая кнопка](../public/assets/blog/sapui5-connect-icons-font/beautiful_button.jpg)\n\nКстати, названия всех иконок и их кодов удобно лежат в файле **/scss/_variables.scss**. И они вполне пригодны для автоматической обработки. Ну а шо, а вдруг.\n\n<iframe width=\"100%\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/TeXk3RFy1rc\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n```scss\n// помимо других переменных, там содержатся $fa-var.* : code\n$fa-var-angry: \\f556;\n$fa-var-angrycreative: \\f36e;\n$fa-var-angular: \\f420;\n$fa-var-ankh: \\f644;\n$fa-var-app-store: \\f36f;\n//.......\n```\n\nНапример, можно автоматически собрать все команды добавления в пул. (Не пытайтесь засунуть всю портянку в проект, это просто пример.)\n\n```bash\ngrep -o fa-var.* ./_variables.scss \\\n | tr --delete \\;\\\\ | awk -F': ' \\\n '{print \"sap.ui.core.IconPool.addIcon(\\\"\"$1\"\\\",\\\"fa\\\",\\\"Font Awesome 5 Free\\\", \\\"\"$2\"\\\");\"}' \\\n > iconDefinition.js\n```\n\nПолучим на выходе вот это:\n\n```JavaScript\nsap.ui.core.IconPool.addIcon(\"fa-var-address-card\",\"fa\",\"Font Awesome 5 Free\", \"f2bb\");\nsap.ui.core.IconPool.addIcon(\"fa-var-adjust\",\"fa\",\"Font Awesome 5 Free\", \"f042\");\nsap.ui.core.IconPool.addIcon(\"fa-var-adn\",\"fa\",\"Font Awesome 5 Free\", \"f170\");\nsap.ui.core.IconPool.addIcon(\"fa-var-adobe\",\"fa\",\"Font Awesome 5 Free\", \"f778\");\n//...\n```\n\nЦелый лонгрид о подключении шрифта... Ух.\n\n![Деградация](../public/assets/blog/sapui5-connect-icons-font/деградация.jpg)\n\nНа этом всё. Работает. \n\nP.S. При тестировании внутри **SAP WEB IDE** на **Internet Explorer** могут наблюдаться фантомные проблемы с отображением иконок. Но после деплоя — всё работает.\n\n#javascript #sapui5 ","ogImage":{"url":"/assets/blog/sapui5-connect-icons-font/background.jpg"},"coverImage":"/assets/blog/sapui5-connect-icons-font/background.jpg","issueId":"17","excerpt":"Разберем процесс на примере шрифта от fontawesome"},{"title":"Как запилить реактивность на SAPUI5 — часть 2","date":"2020-06-21T14:15:07.322Z","slug":"sapui5-state-part2","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120&v=4","url":"https://github.com/JustAddAcid"},"content":"\nС концептом реактивности в *SAPUI5* немного разобрались. Осталось углубиться в эту тему чуть-чуть подробнее: \n\n1. Разобраться с тем, что же такое *expression binding* и с чем его едят\n2. А также ответить на вопрос — как подписываться на изменение *viewState* и выполнять по этому событию какой-либо код. \n\n![Добра поешь](../public/assets/blog/sapui5-state-part2/добра%20поешь.png)\n\n## Что же такое expression binding и с чем его едят\n\nВ прошлой статье я немного рассказывал о реактивности в *sapui5* и показывал пример привязки элементов экрана к данным. Если ещё не читали, то [добро пожаловать сюда](./sapui5-state).\n\nВ тех примерах байндинги описывались прямо в xml верстке. Примерно в таком формате:\n```xml\n<Control property=\"{modelName>modelProp}\"/>\n```\nВ этом случае в свойство контрола автоматически будет попадать значение из модели и автоматически обновляться, если данные в модели изменились.\n\nНо это далеко не всё, что мы можем описать прямо во вью в декларативном стиле. Например, в некоторых ситуациях очень нужно именно **вычислять** значение поля на основании данных в модели, а не просто показывать какое-то значение.\n\n**Возможные сценарии:**\n\n1. Подкрашивать красным строки таблицы, где значение какого-нибудь столбца меньше нуля\n2. Активировать/деактивировать на основании данных кнопки\n3. Выводить количество записей в массиве и т.д.\n\n*Ремарка: сейчас речь пойдет только про *expression binding*. Про форматтеры поговорим как-нибудь в другой раз.*\n\nИ такой функционал вычисления свойств *sapui5* нам охотно может предоставить.\n\n```xml\n<Control property=\"{= JS_CODE}\"/>\n```\nВсё это выглядит следующим образом: сразу после открывающейся фигурной скобки вставляем знак равенства, так парсер понимает, что дальше будет какое-то вычисляемое поле на *js*. Далее можно поместить маленький кусок кода на *javaScript*, который будет выполняться при вычислении содержимого поля. \n\n*(Вставлять туда можно константы, вызовы функций, тренарные?операторы:, регэкспы и прочие прелести жизни.)*\n\nГлавное — не переусердствовать и не превратить разметку страницы в помойку. :)\n\nСсылаться на содержимое модели можно с помощью конструкции **${}**. Например: \n\n```xml\n<Text text=\"{= 'Hello, ' + ${user>name}}\">\n```\nВ данном случае после *\"Hello, \"* будет подставлено *\"name\"* из модели *\"user\"*. И если в будущем поле **user>name** изменится — автоматически произойдет повторное вычисление всех *expression bindings*, связанных с этим полем.\n\n**Ахтунг:**\nБудьте внимательны с *boolean*-атрибутами! \n```xml\n<Button enabled=\"{= someFunction( ${model>prop} )}\">\n```\nВ примере выше значение *enabled* (с типом *bool*) принимается из результата функции *someFunction*. Но если по каким-то причинам из функции возвратится **undefined**, то это значение **не будет** воспринято как *falsy* (как во всём остальном js), а мистическим образом конвертируется в **true**. Так что, конкретно в этом случае, может быть оправдана вот такая грязная и некрасивая запись (за которую вас могут ударить по рукам):\n```xml\n<Button enabled=\"{= !!someFunction( ${model>prop} )}\">\n<!-- или -->\n<Button enabled=\"{= someFunction( ${model>prop} ) ? true : false }\">\n```\n\nПопробую привести более полные и понятные примеры того, где эти *expression bindings* можно удобно использовать:\n\n### Раскрывающееся меню\n\nДопустим, нам требуется выпадающее меню вот с таким поведением: при нажатии на toggleButton должна меняться иконка и открываться дочерняя ветка меню. Как это сделать, почти не прибегая к *javaScript*?\n\n![menu closed](../public/assets/blog/sapui5-state-part2/menu%20closed.png)\n![menu opened](../public/assets/blog/sapui5-state-part2/menu%20opened.png)\n\nОчень просто: использовать для иконок тренарный оператор, который будет вычислять нужную нам иконку. А \"дочернюю\" ветку меню заключить в блок, который делать видимым тогда, когда свойство TransportEnabled в модели будет = true.\n\nПример верстки:\n\n```xml\n<VBox>\n  <ToggleButton text=\"Движение транспорта\"\n    icon=\"{= ${/TransportEnabled} ? 'иконка вкл' : 'иконка выкл'\"\n    pressed=\"{/TransportEnabled}\"/>\n  <VBox visible=\"{/TransportEnabled}\">\n    <ToggleButton text=\"В пути\" \n      icon=\"{= ${/TransportOnWay} ? 'иконка вкл' : 'иконка выкл'}\"\n      pressed=\"{/TransportOnWay}\"/>\n    <ToggleButton text=\"На подходе\"\n      icon=\"{= ${/TransportApproaching} ? 'иконка вкл' : 'иконка выкл'}\"\n      pressed=\"{/TransportApproaching}\"/>\n    <ToggleButton text=\"Прибыл\" \n      icon=\"{= ${/TransportArrived} ? 'иконка вкл' : 'иконка выкл'}\"\n      pressed=\"{/TransportArrived}\"/>\n  </VBox>\n</VBox>\n```\n\n### Калькулятор\n\nДопустим, мы захотели написать простой калькулятор на *sapui5*. Как нам организовать блокировку кнопки \"decimal point\", когда точка уже введена пользователем? \n\n![calc before](../public/assets/blog/sapui5-state-part2/calc%20before.png)\n![calc after](../public/assets/blog/sapui5-state-part2/calc%20after.png)\n\n*Не сильно заметно, но на втором скрине кнопка с точкой заблокирована*\n\nМожно писать отдельный метод проверки, а можно сделать вот так:\n\n```xml\n<!-- Само поле ввода чисел в калькулятор -->\n<Input enabled=\"false\" value=\"{viewState>/input}\"/>\n\n<!-- ... -->\n\n<Button text=\".\" \n  press=\"appendSymbolToLine\" \n  enabled=\"{= !${viewState>/input}.includes('.') }\"/>\n```\n\nПросто проверять, есть ли в строке ввода точки :)\n\n**И напоследок расскажу, как привязывать хендлеры к изменению конкретного свойства в JSON-модели:**\n\nХитрость заключается в том, что если для этого мы будем использовать класс **sap.ui.model.Binding**, то у нас ничего хорошего не получится. Т.к. хендлер будет запускаться каждый раз, когда изменится **вообще какое-либо** поле в этой модели. \n\nА для привязки к конкретному полю существует специальный класс: **sap.ui.model.json.JSONPropertyBinding**.\n\nДавайте прикрутим к нашему калькулятору какой-нибудь хендлер изменения данных в модели. Например, будем рисовать toast-сообщение при записи значения в память нашего калькулятора (при нажатии кнопок M+ и M-)\n\nДля удобства напишем метод, который будет принимать два аргумента: путь до данных в модели, за которыми будем наблюдать, и функцию, которая будет запускаться при изменении этого поля:\n\n```javascript\n  addViewStateListener: function(path, callback) {\n    var oBinding = new sap.ui.model.json.JSONPropertyBinding(this.viewState, path);\n    oBinding.attachChange(callback);\n  }\n```\n\nЗатем напишем функцию, вызывающую сообщение и привяжем её к данным\n\n```javascript\n  memoryUsage: function(event){\n    sap.m.MessageToast.show(\"Memory usage! Set \" + event.getSource().getValue());\n  }\n\n// [....]\n  onInit: function() {\n  // [....]\n  // При инициализации привязываем нашу функцию к проперти модели\n  this.addViewStateListener(\"/memory\", this.memoryUsage);\n}\n```\n\nГотово! При нажатии на m+ получаем вот такое сообщение:\n\n![Calc handler](../public/assets/blog/sapui5-state-part2/calc_handler.jpg)\n\nКак всегда, код примера [вот здесь](https://github.com/JustAddAcid/sapui5-calculator)\n\nЕщё увидимся\n\n#javascript #sapui5 ","ogImage":{"url":"/assets/blog/sapui5-state-part2/backgroundWithHeader.png"},"coverImage":"/assets/blog/sapui5-state-part2/backgroundWithHeader.png","issueId":"11","excerpt":"Expression binding & viewstate change handling"},{"title":"Как запилить реактивность на SAPUI5 — часть 1","date":"2020-06-15T14:15:07.322Z","slug":"sapui5-state","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120&v=4","url":"https://github.com/JustAddAcid"},"content":"\nРешил описать то, как можно удобно хранить состояния экранов (или всего приложения) внутри *SAPUI5* и делать реактивность (Почти как у больших и нормальных фреймворков).\n\n**Для тех, кто в танке и никогда не слышал, что это такое** *SAPUI5* — это фронтенд-фреймворк. Как  хипстерские *Vue* и *React*, только никому не нужен. Используется для быстрого написания фронтендов поверх выгрузки данных из SAP-ERP. \n\nВнезапно, но он действительно неплохо интегрирован со всей сап-экосистемой и простенькие приложения (внутри определенных рамок) писать не сильно больно. Проблемы начинаются тогда, когда нужно сделать что-то *большее*, чем просто нарисовать табличку с двумя кнопками. И внезапно вылезают всеобщая громоздкость синтаксиса, нестабильность работы некоторых контролов и отсутствие нормального комьюнити.\n\n![Learning programming sapui5](../public/assets/blog/sapui5-state/meme.png)\n\n## Стейты стейты стейты\n\n### Для начала немного теории\n\nЧто такое реактивное программирование очень хорошо объяснено [здесь](https://webdevblog.ru/ponimanie-reaktivnosti-vo-vue-js-shag-za-shagom/) только примеры для другого фреймворка. Но это не важно! :)\n\nВ основе лежит идея о том, что было бы очень неплохо, если бы контролы сами смотрели в данные и **перестраивались** бы автоматически, если что-нибудь в этих данных поменяется, без кучи явных хендлеров и присвоений значений в контролы по многу раз. \n\nИ наоборот — было бы неплохо, если бы данные **перестраивались** автоматически, если, например, в каком-нибудь input'e пользователь ввел другое значение.\n\n#### Вот такой вот интересный **two-way binding** ¯\\\\_(ツ)_/¯\n\nДавайте человеческим языком — суть в том, что все данные у нас сложены в одну коробку (массив/объект) и все контролы на странице рендерятся на основе этих данных. \n\nПлюсы здесь в том, что это, мать его, облегчает чтение и уменьшает размер нашего нелюбимого жабаскрипта. А чем меньше жабаскрипта — тем лучше.\n\nА ещё сразу понятно, что приложение делает, если взглянуть на модель данных. А ещё это кодится быстрее за ту же зарплату. Ну вы понимаете.\n\n### Разберем на практике избитый пример:\n\n#### Тудушница\n\nДавайте за минуту напишем простейший toDo-лист с единым хранением состояния. \n\nДля начала создаём пустое *SAPUI5* приложение с единственной view — *index.view.xml*, которая сразу при открытии будет отображаться пользователю. \n\nИдем от данных! Какие данные примерно должна хранить todo-list? Наверное, массив заметок с полями: checked, text, и id. Ну и содержимое текстового поля, которое генерирует новые заметки. Получилось примерно вот так:\n\n```javascript\n{\n    input: \"\",\n    todos: [\n    // Тут будут объекты вот в таком формате:\n    // \t{\n    // \tid: \"1\",\n    // \ttext: \"one\",\n    // \tchecked: true\n    // }\n    ]\n  }\n```\n\nСостояние в *SAPUI5* лучше всего хранить в объекте класса sap.ui.model.json.**JSONModel**. Он позволяет подписываться на изменения каждого из свойства хранимого объекта, - как из XML-view в декларативном стиле, так и напрямую писать хендлеры изменений из кода. Почему класс называется именно JSONModel - для меня остаётся загадкой, т.к. де-факто он хранит обычный JavaScript объект.\n\nОткрываем файл */controller/index.controller.js* и по событию инициализации создаём *JSON-model* и заполняем её данными.\n\n```javascript\n  onInit: function() {\n    this.viewState = new JSONModel({\n      input: \"\",\n      todos: []\n    });\n\n    this.getView().setModel(this.viewState, \"viewState\");\n  }\n```\n\nМодель присваивается к *View* с помощью метода *.setModel*. В данном конкретном случае псевдоним модели (\"*viewState*\") можно было не указывать, т.к. модель всего одна и путаницы возникнуть не может. \n\nДавайте попробуем представить, как бы у нас выглядел метод создания новой заметки:\n\n```javascript\n  appendTodo: function(){\n    var todos = this.viewState.getProperty(\"/todos\");\n    \n    this.viewState.setProperty(\"/todos\", todos.concat([{\n      id: new Date().getTime().toString(),\n      text: this.viewState.getProperty(\"/input\"),\n      checked: false\n    }]));\n    \n    this.viewState.setProperty(\"/input\", \"\");\n  },\n```\n\nОчень просто. Получение массива заметок, создание массива со старыми + новой заметкой и присвоение его к модели. Затем очистка поля ввода.\n\nВ качестве id нам пока вполне подойдет текущий таймстемп. Вместо Array.prototype.concat, если очень хочется, можно использовать ES6 spread operator:\n\n```javascript\n  const newArray = [...oldArray, newElement]\n```\n\nНо не очень нужно, т.к. у sapui5 из коробки нет никакого препроцессинга кода, а написанный энтузиастами плагин для Babel не для production-use. И используя фичи es6 мы автоматически делаем наш код неспособным запуститься на ie10-11 (а у некоторых он до сих пор — корпоративный стандарт).\n\nПереходим к разметке интерфейса. Там всё просто: поле создания заметок + список.\n\n```xml\n  <content>\n    <Input value=\"{viewState>/input}\" submit=\"appendTodo\"/>\n    <List items=\"{viewState>/todos}\">\n      <items>\n        <CustomListItem>\n          <HBox>\n            <CheckBox selected=\"{viewState>checked}\"/>\n            <Input width=\"500px\" value=\"{viewState>text}\"/>\n            <Button text=\"X\" press=\"deleteTodo\" data:id=\"{viewState>id}\"/>\n          </HBox>\n        </CustomListItem>\n      </items>\n    </List>\n  </content>\n```\n\nID заметки будем передавать в data-* атрибуте. (Чтобы неймспейс data: в разметке заработал, нужно его подключить в самом верху view)\n\n```xml\n<mvc:View \n  controllerName=\"todoTodo.controller.index\" \n  xmlns:html=\"http://www.w3.org/1999/xhtml\"\n  xmlns:mvc=\"sap.ui.core.mvc\"\n\tdisplayBlock=\"true\" \n  xmlns=\"sap.m\" \n  xmlns:data=\"http://schemas.sap.com/sapui5/extension/sap.ui.core.CustomData/1\">\n```\n\nМетод удаления заметки: Получаем id из data-* атрибута и фильтруем массив.\n\n```javascript\n  deleteTodo: function(event){\n    var id = event.getSource().data(\"id\");\n    var todos = this.viewState.getProperty(\"/todos\");\n    this.viewState.setProperty(\"/todos\", todos.filter(function(todo){\n      return todo.id !== id;\n    }));\n  }\n```\n\nЗапускаем — работает! Написано всего два простых метода. \n\nСейчас нам **ничего** не стоит забрать данные и записать в *localStorage* браузера, или отправить на *сервер*, или как-то обрабатывать в коде, т.к. мы всегда знаем, где находятся данные и как они организованы.\n\nА теперь давайте представим, сколько бы нам потребовалось геморроя, если бы мы писали это в классическом html+js... Приходилось бы руками описывать хендлеры событий каждого контрола, а сборка данных для отправки на сервер превратилась бы в сущий ад в виде цикла по всем контролам и вытаскивания значения. Конечно, для данного примера этот аргумент звучит не слишком сурово. Но представьте здоровенное *SPA* приложение с несколькими сотнями контролов в сложной иерархии...\n\nА пока - простейшее туду:\n\n![Запускаем — работает](../public/assets/blog/sapui5-state/basic-todo.png)\n\nВ представленном варианте: в модели *viewState* будет храниться объект со следующим содержанием:\n\n```javascript\n{\n    input: \"\"\n    todos: {\n        { id: \"1592739272730\", text: \"Раз\", checked: false }\n        { id: \"1592739273593\", text: \"Два\", checked: true }\n        { id: \"1592739274600\", text: \"Три\", checked: false }\n        { id: \"1592739276362\", text: \"Четыре\", checked: true }\n        { id: \"1592739277545\", text: \"Пять\", checked: false }\n    }\n}\n```\n\n[Репо с кодом](https://github.com/JustAddAcid/sapui5-todo)\n\nПродолжение следует.\n\n#javascript #sapui5","ogImage":{"url":"/assets/blog/sapui5-state/cover2withHeader.png"},"coverImage":"/assets/blog/sapui5-state/cover2withHeader.png","issueId":"10","excerpt":"Решил описать то, как можно удобно хранить состояния экранов (или всего приложения) внутри SAPUI5 и заниматься реактивностью (Почти как у больших и нормальных фреймворков)"},{"title":"Автоматизируем деплой статического сайта с помощью CircleCI","date":"2020-05-05T16:12:07.322Z","slug":"circle-ci","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120&v=4","url":"https://github.com/JustAddAcid"},"content":"\nС хостингом и комментариями немного разобрались. Теперь заставим нашу шайтан-машину автоматически пересобирать сайт, если в .md шаблонах произошли какие-то изменения. Потому что нет никакого желания **каждый раз** после минимального изменения статьи делать руками билд, перетаскивать собранные *html* страницы в другой репозиторий и коммитить. Естественно, это можно и нужно оптимизировать. В качестве подопытного кролика сегодня выступает сервис *CircleCi*, у которого достаточно удобный бесплатный тариф, которого нам будет более чем достаточно.\n\n**Для тех, кто в танке и никогда об этом не слышал:** *CircleCi* — это облачный сервис для continuous integration. Умеет следить за изменениями в Git-репозиториях и пересобирать билды приложений, прогонять тесты и т.д. Тестить в статическом блоге толком нечего, а вот функция собирать билды нам как раз пригодится.\n\n**Для бородатых админов:** я не большой спец в CI, так что, если код будет не совсем согласован с общепринятыми Best-Practice, то прошу меня извинить и прошу написать в комментариях о том, как это сделать лучше и безопасней.\n\n## Автоматизировали, автоматизировали, да не выавтоматизировали\n![If you never deploy, your deploy never falls](../public/assets/blog/circleci/meme.jpeg)\n\nИтак, поехали. Для начала, нужно определиться, что за нас должна делать шайтан-машина. \nПредварительный алгоритм:\n\n1. Скрипт проверяет все .md файлы с постами на предмет того, создана ли для него issue на GitHub (для реализации комментариев, [о которых здесь](./issue-comments-github))\n2. Если к .md файлу не привязана issue, то создать, и записать в файл issue id. Сделать коммит и пуш\n3. Сделать билд в статический html\n4. Положить файлы билда в репозиторий с github pages (JustAddAcid.github.io). Сделать коммит и пуш\n\n## Реализация — скрипт проверки и привязки issue\nВ package.json объявим скрипт issues, который запускает файл issues.mjs из корня. \n\n```javascript\n{\n  \"scripts\": {\n    \"dev\": \"next\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"export\": \"next export\",\n    \"issues\": \"node issues.mjs\" //  <--- \n  }\n}\n```\nВ issues.mjs следующая логика: во всех файлах с постами скрипт ищет подстроку %%ISSUЕ_ID%%. И если находит, то создаёт новое GitHub Issue, а его ID подставляет вместо %%ISSUЕ_ID%%.\n```javascript\nconst issueNotCreatedYet = '%%ISSUЕ_ID%%',\n      notCreatedRegExp = new RegExp(issueNotCreatedYet, 'g')\n\n//...\n\nconst main = async () => {\n\n    const filesInDir = fs.readdirSync(postsDir) // получаем имена файлов в директории\n    \n    for (const fileName of filesInDir){\n        const filePath = postsDir + '/' + fileName,\n              fileText = fs.readFileSync(filePath).toString(),\n              nameWithoutExtension = fileName.split('.')[0]\n    \n        if (fileText.includes(issueNotCreatedYet)){ \n            const issueId = await createIssue(nameWithoutExtension),\n                  newText = fileText.replace(notCreatedRegExp, issueId)\n            fs.writeFileSync(filePath, newText);\n        }\n    \n    }\n}\n```\nА функция, createIssue представляет собой post-запрос в github api\n```javascript\nconst createIssue = async name => {\n    const url = `https://api.github.com/repos/${githubUser}/${targetRepo}/issues`\n    const response = await fetch(url, {\n        method: 'post',\n        body: JSON.stringify({\n            title: 'Comments: ' + name,\n            body: postPrefix + name\n        }),\n        headers: {\n            'Accept' : 'application/vnd.github.v3.html+json',\n            'Content-Type': 'application/json',\n            'Authorization': basicAuthHeader(githubUser, password) \n        }\n    })\n    const createdIssue = await response.json();\n    return createdIssue.number.toString();\n}\n```\n\n*В примере выше для авторизации на GitHub используется basic auth header, который сейчас является **deprecated**. Такая возможность авторизоваться будет **удалена** в ноябре 2020. [Больше информации здесь.](https://developer.github.com/changes/2020-02-14-deprecating-password-auth/ \"Deprecating password authentication\")*\n\nТеперь мне нужно запомнить, что всегда, когда я хочу, чтобы система автоматически создала issue, нужно вместо ID созданной руками issue писать директиву %%ISSUЕ_ID%%\n```javascript\n{\n    excerpt: 'С хостингом и комментариями немного разобрались. Теперь заставим нашу шайтан-машину пересобирать сайт, если в .md шаблонах произошли какие-то изменения'\n    coverImage: '/assets/blog/circleci/cover.png'\n    date: '2020-05-05T16:12:07.322Z'\n    issueId: '%%ISSUЕ_ID%%'\n}\n```\n\n\n## Реализация — конфиг CircleCi\nКонфиг *CircleCi* представляет собой **config.yml** файл в директории **.circleci** в корне вашего репозитория. Сам конфиг-файл содержит описания шагов, которые должен сделать сервер, чтобы задеплоить ваше приложение и/или запустить тесты. \n\nНо для начала нужно примерно представить, какие действия (shell-команды) нам всё-таки нужно проделать. У меня получилось как-то так:\n\n```bash\n# Представляемся гиту\ngit config --global user.email $GH_EMAIL\ngit config --global user.name $CIRCLE_USERNAME\n\n# Запускаем скрипт проверки issues\nnpm run issues\nif [[ `git status --porcelain` ]]; then\n  # Если мы изменили какие-то файлы — делаем коммит. \n  # А деплой будем делать в следующем таске, которые запустится при коммите\n  git add -A\n  git commit -m \"Automated issues creation: ${CIRCLE_SHA1}\"\n  git push\n  echo \"Pushed changes in current repo. Deploy in next task\"\n  circleci-agent step halt\nfi\n\nnpm run build\n\n# Клонируем репозиторий сайта во временную папку и удаляем лишние директории\ngit clone $TARGET_REPO_URL targetDirectory\ncd ./targetDirectory/\nrm -rf ./_next\nrm -rf ./assets\nrm -rf ./favicon\nrm -rf ./posts\necho \"deleting folders from $PWD\"\ncd ..\n# Инициируем экспорт проекта в статические html\nnpm run export\n# Перекладываем html в наш репозиторий с сайтом\n/bin/cp ./out/* ./targetDirectory/ -R -f\ncd ./targetDirectory/\necho \"commit in dir $PWD into $TARGET_REPO_URL repo\"\ngit add -A\ngit commit -m \"Automated deployment to GitHub Pages: ${CIRCLE_SHA1}\" --allow-empty\ngit push\n```\n\nОсталось натянуть этот скрипт на конфиг **CircleCi**:\nСоздаём в репозитории директорию **.circleci**, в ней файл **config.yml** с примерно следующим содержанием:\n```yaml\nversion: 2.1\njobs:\n  build:\n    docker:\n      - image: circleci/node:latest\n    steps:\n      - checkout\n      - restore_cache:\n          keys:\n            - v1-dependencies-\n            - v1-dependencies-\n      - run:\n          name: Install dependencies\n          command: npm install\n      - save_cache:\n          paths:\n            - node_modules\n          key: v1-dependencies-\n      - deploy:\n          name: Deploy\n          command: |\n            git config --global user.email $GH_EMAIL\n            git config --global user.name $CIRCLE_USERNAME\n\n            # .... тот shell-скрипт, который представлен выше\n```\nОстались мелочи:\n\n1. Зайти на сайт #CircleCi, залогинившись своим аккаунтом GitHub\n2. Во вкладке projects выбрать нужный репозиторий\n3. Передать все используемые в скриптах переменные окружения\n4. Создать user-key (для возможности коммита в репозиторий)\n\n\nВ итоге, при каждом коммите в репозиторий будет просыпаться скрипт в CircleCi и пересобирать статический блог.\n\nЕщё увидимся.\n\n#javascript #bash ","ogImage":{"url":"/assets/blog/circleci/cover.png"},"coverImage":"/assets/blog/circleci/cover.png","issueId":"7","excerpt":"С хостингом и комментариями немного разобрались. Теперь заставим нашу шайтан-машину пересобирать сайт, если в .md шаблонах произошли какие-то изменения"},{"title":"Использование issues в GitHub как движок комментариев","date":"2020-05-04T14:15:07.322Z","slug":"issue-comments-github","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120&v=4","url":"https://github.com/JustAddAcid"},"content":"\nХочу поделиться замечательной идеей: превращения **GitHub issues** в полноценный движок комментариев для статического блога. Достойная легковесная (и бесплатная!) замена *disqus* и аналогов.\nДля начала, маленькая вводная, с чего всё начиналось:\n\nБыл скучный выходной день во время карантина и я лениво читал интернеты в поисках удобного движка комментариев для своего блога. Я уже был готов поддаться маркетингу disqus'a, но внезапно наткнулся на интересную статью:\n\n(http://donw.io/post/github-comments/)\n\nВ ней автор анализирует трафик своего сайта и приходит к удручающему выводу: *disqus* настолько активно использует трекеры и прочие запросы на сервер, что в примере автора, увеличивал количество XHR-запросов с 16 до 105! Это совершенно неприемлемо. И в качестве альтернативы, рассказчик предлагает переход к ... GitHub Issues! \n\nВ статье прелагается следующая схема:\n\n1. На каждый пост в блоге открывается *issue в GitHub*\n2. Все комментарии создаются непосредственно на сайте *GitHub*\n3. При открытии страницы, клиентский JavaScript код получает все комментарии из issue через *issue API*\n\n## Заводим свой ~~трактор~~ велосипед\n![Возможно всё, но зачем?](../public/assets/blog/issue-comments-github/но_зачем.png)\n\nИ тут я подумал, что раз уж весь мой блог использует *GitHub Pages* в качестве хостинга, то почему бы не попробовать ещё больше интегрироваться в экосистему гитхаба?\n\n### Предварительный алгоритм работы с комментариями (пока я не автоматизировал деплой):\n\n1. Перед созданием поста, руками создаётся issue, оттуда копируется ID и вставляется в .md-темплейт поста.\n2. В исходники страницы добавлен маленький скрипт, который подхватывает этот id страницы и по нему (через Github API получает все комментарии (отрендеренный markdown в html)\n3. Рендер комментариев. \n4. Добавление кнопки \"создать комментарий\", который просто перебрасывает пользователя на страницу GitHub\n\n### Реализация\n\nПоскольку я храню все посты на этом сайте в markdown файлах, мне первым делом нужно запомнить, что при создании файла, в метаданных я теперь буду обязан указывать issue id.\n\n```javascript\n{\n    title: 'Первый пост с использованием markdown и next js'\n    excerpt: 'А заодно и проверка возможности писать на кириллице в этом шаблонизаторе. Если вы читаете этот текст, значит полет нормальный.'\n    coverImage: '/assets/blog/hello-world/завтра_будет_лучше.jpg'\n    date: '2020-05-03T21:00:07.322Z'\n    issueId: '1' // <--- id созданного issue на GitHub\n} \n```\nВ конец страницы с постом добавлен React-компонент Comments, который будет отображать комментарии из ГитХаба. \n\n```html\n    <article>\n        <Comments \n            githubUser=\"JustAddAcid\"\n            githubRepo=\"JustAddAcid.github.io\"\n            issueId={post.issueId} />\n    </article>\n```\n\nВнутри компонента **Comments** делаем GET-запрос в https://api.github.com/repos/ ${githubUser}/ ${githubRepo}/issues/ ${issueId}/comments. Например, для комментариев к этой странице, это будет:\n\n(https://api.github.com/repos/ JustAddAcid/JustAddAcid.github.io/ issues/2/comments)\n\n```javascript\ncomponentDidMount() {\n    if (!this.state.data) {\n        const githubUser = this.props.githubUser\n        const githubRepo = this.props.githubRepo\n        const issueId = this.props.issueId\n\n        const that = this;\n        window.fetch(`https://api.github.com/repos/${githubUser}/${githubRepo}/issues/${issueId}/comments`, {\n            headers: {\n                Accept: 'application/vnd.github.v3.html+json'\n            }\n        })\n            .then(response => response.json())\n            .then(comments => that.setState({\n                data: comments,\n                isLoading: false\n            }))\n```\n\nНу и красиво рендерим JSON-array, который нам пришел из гитхаба\n\n```javascript\n    render(){\n        // ....\n        {hasData && (\n            this.state.data.map(comment => (\n                <Comment\n                    key={comment.id}\n                    avatarUrl={comment.user.avatar_url}\n                    userProfileUrl={comment.user.html_url}\n                    userLogin={comment.user.login}\n                    commentDate={comment.created_at}\n                    commentBody={comment.body_html} />\n            ))\n        )}\n        <LinkButton text=\"Добавить комментарий\" link={`https://github.com/${githubUser}/${githubRepo}/issues/${issueId}`} />\n    }\n```\n\nПосле причесывания стилей — получаем достаточно минималистичную и приятную на глаз систему комментариев с поддержкой markdown, цитирования и т.д., которой можно воспользоваться внизу страницы.\n\nЕщё увидимся.\n\n#танцы_с_бубном #javascript ","ogImage":{"url":"/assets/blog/issue-comments-github/cover.png"},"coverImage":"/assets/blog/issue-comments-github/cover.png","issueId":"2","excerpt":"Хочу поделиться замечательной идеей: превращения GitHub issues в полноценный движок комментариев для статического блога. Достойная легковесная (и бесплатная!) замена disqus и аналогов."}],"tag":"javascript"},"__N_SSG":true}